<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/08/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>解决Git--Unsupported-SSL-backend</title>
    <url>/2021/08/12/Git/%E8%A7%A3%E5%86%B3Git-Unsupported-SSL-backend/</url>
    <content><![CDATA[<h2 id="解决Git–Unsupported-SSL-backend"><a href="#解决Git–Unsupported-SSL-backend" class="headerlink" title="解决Git–Unsupported-SSL-backend"></a>解决Git–Unsupported-SSL-backend</h2><span id="more"></span>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.sslBackend</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git_fix</tag>
      </tags>
  </entry>
  <entry>
    <title>Jar文件打包</title>
    <url>/2021/08/12/Java/Jar%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p>Java归档文件，更多细节请参考：<a href="https://docs.oracle.com/javase/10/docs/specs/jar/jar.html">Oracle JAR Help</a></p>
<span id="more"></span>

<h2 id="JAR文件简介"><a href="#JAR文件简介" class="headerlink" title="JAR文件简介"></a>JAR文件简介</h2><p>如果你手上已经有一个自制的工具包,并且你希望你工具包能够以单独的文件的形式来被用户使用，而不是包含很多代码的一个目录结构，那么Java归档文件（JAR）就能够帮助你</p>
<h2 id="创建JAR文件"><a href="#创建JAR文件" class="headerlink" title="创建JAR文件"></a>创建JAR文件</h2><p>如今的IDE已经非常智能，可以不用管Java的命令行具体细节就能实现打包JAR文件，但是这里还是要解释下JAR相关的命令行，既方便跨平台也可以在必要时处理打包JAR产生的错误。</p>
<p>在<code>jdk\bin</code>目录下，有一个JAR工具（jar.exe）可以用它来创建JAR包，其语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar cvf jarFilename file1 file2 ...</span><br><span class="line">jar [options] file1 file2...-</span><br></pre></td></tr></table></figure>

<p>对于[options]命令，可以有下选项：</p>
<p><img src="/2021/08/12/Java/Jar%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/image-20210407210830146.png" alt="image-20210407210830146"></p>
<h2 id="创建可执行的JAR文件"><a href="#创建可执行的JAR文件" class="headerlink" title="创建可执行的JAR文件"></a>创建可执行的JAR文件</h2><p>使用JAR命令中的e选项指定程序的入口点类（即带main方法的类）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar cvfe Tools.jar com.tools.mytools.MainClass ...</span><br></pre></td></tr></table></figure>

<p>还有一种方法，可以在清单文件（下个小节会有说明）中指定程序的主类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Main-Class: com.tools.mytools.MainClass</span><br></pre></td></tr></table></figure>

<p><strong>注意：清单文件的最后一行必须以换行符结尾，所以上面的代码结尾的换行不是打错！否则清单文件无法被正确地读取！</strong></p>
<p>使用上面的方法创建可执行的JAR文件，要运行该JAR包，需要执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar Tools.jar</span><br></pre></td></tr></table></figure>

<h2 id="清单文件"><a href="#清单文件" class="headerlink" title="清单文件"></a>清单文件</h2><p>除了类文件、图像和其他资源外，每个JAR文件还包含一个清单文件，用于描述归档文件的特殊特性。</p>
<p>清单文件名字一般为：MANIFEST.MF，在一个特殊的META-INF子目录中。</p>
<p>一般最小的清单文件非常简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br></pre></td></tr></table></figure>

<p>更多细节可以参考：<a href="https://docs.oracle.com/javase/10/docs/specs/jar/jar.html">Oracle JAR Help</a></p>
<p>要创建包含清单文件的JAR需要运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar cfm Tools.jar mainfest.mf classfile1 ...</span><br></pre></td></tr></table></figure>

<h2 id="在IDEA中创建JAR包"><a href="#在IDEA中创建JAR包" class="headerlink" title="在IDEA中创建JAR包"></a>在IDEA中创建JAR包</h2><p>IDEA中创建使用JAR操作非常简单，参考：</p>
<h3 id="File–-gt-项目结构中："><a href="#File–-gt-项目结构中：" class="headerlink" title="File–&gt;项目结构中："></a>File–&gt;项目结构中：</h3><p><img src="/2021/08/12/Java/Jar%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/image-20210407211249011.png" alt="image-20210407211249011"></p>
<p><img src="/2021/08/12/Java/Jar%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/image-20210407211432890.png" alt="image-20210407211432890"></p>
<p><img src="/2021/08/12/Java/Jar%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/image-20210407211528409.png" alt="image-20210407211528409"></p>
<p><img src="/2021/08/12/Java/Jar%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/image-20210407211611167.png" alt="image-20210407211611167"></p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>如果发现<code>idea</code>按照上面的步骤做下来，还是没办法打包，请确认下工程目录里有没有<code>MANIFEST.MF</code></p>
]]></content>
      <categories>
        <category>java学习笔记</category>
      </categories>
      <tags>
        <tag>java_jar</tag>
      </tags>
  </entry>
  <entry>
    <title>Java代理</title>
    <url>/2021/09/09/Java/Java%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>Java 代理，主要主要是指动态代理，是学习AOP的基础，该知识点非常重要，有必要好好了解！</p>
<p>针对<code>java</code>语言，我打算出一些语言的核心知识和一些类库的使用，还有自己翻译的API，都会放在博客里面供参考。</p>
<p>各位有需要可以在tags那里点击所有以<code>java</code>开头的标签，这些标签的意义如下：</p>
<ul>
<li>java_core：核心的java知识，包括反射、泛型、注解、代理……</li>
<li>java_lib：各类java类库的使用基础，java的API，或者一些API的历史</li>
<li>java_features：java的特性，包括java的语法糖，java各版本的更新特性等</li>
<li>……</li>
</ul>
<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在实战mybatis，在研究实现原理的时候，重新又把焦点放在了代理模式上，因此记下此篇。</p>
<p>java代理实际为动态代理，用起来可能比较抽象，但实际上并没有那么难。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>要想完全弄清楚代理，我认为还是要先从静态代理出发，首先我们传统方法上的调用可以被归纳为一个对应关系，<strong>即调用方调用被调用方的方法，被调用方返回结果给调用方</strong>：</p>
<p><img src="/2021/09/09/Java/Java%E4%BB%A3%E7%90%86/image-20210902162423038.png" alt="image-20210902162423038"></p>
<p>这种调用很常见，但是如果遇到下面的情况：</p>
<ul>
<li>被调用方不想暴露自己的方法给调用方</li>
<li>被调用方是一个已经打包好的包且调用方法前后需要做一些预处理事务</li>
</ul>
<p>那么就需要一个“第三者”来帮助调用方进行方法调用。可以称这个“第三者”为<strong>代理对象</strong></p>
<p><img src="/2021/09/09/Java/Java%E4%BB%A3%E7%90%86/image-20210902163304246.png" alt="image-20210902163304246"></p>
<p>这样调用方调用的时候，代理对象对调用请求进行预处理，然后调用被调用方的相应方法，再返回。</p>
<p>这种设计方法应用场景非常多，比如在<strong>交流通信中的黑名单功能</strong>，可以参考下面代码的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Connection.java</span></span><br><span class="line"><span class="comment">// Connection为接口，代理类和被调用方类都要实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Connection</span> </span></span><br><span class="line"><span class="class">	// 建立连接通信通道，连接成功返回<span class="title">true</span>，连接失败返回<span class="title">false</span></span></span><br><span class="line"><span class="class">	<span class="title">boolean</span> <span class="title">connect</span>(<span class="title">Socket</span> <span class="title">socket</span>)</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConnectionImpl.java</span></span><br><span class="line"><span class="comment">// 被调用方</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionImpl</span> <span class="keyword">implements</span> <span class="title">Connection</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">		<span class="comment">// 具体建立连接的代码</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConnectionImplProxy.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionImplProxy</span> <span class="keyword">implements</span> <span class="title">Connection</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ConnectionImpl impl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 初始化impl的相关方法</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">		<span class="comment">// 判断对方IP是否在黑名单内</span></span><br><span class="line">		<span class="keyword">boolean</span> isBlackGuy = checkFromBlacklist(socket.getInetAddress());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果对方是黑名单成员，则不建立通信连接，否则，建立连接</span></span><br><span class="line">		<span class="keyword">if</span>(isBlackGuy)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> impl.connect(socket);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他们的关系可以使用下图表达</p>
<p><img src="/2021/09/09/Java/Java%E4%BB%A3%E7%90%86/image-20210902165843702.png"></p>
<h3 id="静态代理的实现"><a href="#静态代理的实现" class="headerlink" title="静态代理的实现"></a>静态代理的实现</h3><ol>
<li>首先需要一个<strong>公共的接口</strong>，<strong>代理类和被调用方都要实现这个接口</strong></li>
<li>代理类要<strong>初始化一个被调用方类的对象作为字段</strong></li>
<li><strong>调用方通过调用代理类的方法</strong>，<strong>代理类调用被调用方的方法</strong>，然后返回结果，这一个过程便是静态代理。</li>
</ol>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理与静态代理的主要不同，就是动态代理对象由Proxy类来生成而不是由程序员通过编码来生成。</p>
<p>要生成一个代理对象，需要提供两个东西：</p>
<ul>
<li>调用处理器</li>
<li>目标接口（一个或多个）</li>
</ul>
<p><img src="/2021/09/09/Java/Java%E4%BB%A3%E7%90%86/image-20210902182406151.png" alt="###"></p>
<h3 id="使用动态代理"><a href="#使用动态代理" class="headerlink" title="使用动态代理"></a>使用动态代理</h3><p>首先要使用动态代理，需要定义一个调用处理器</p>
<h4 id="调用处理器"><a href="#调用处理器" class="headerlink" title="调用处理器"></a>调用处理器</h4><p>所谓调用处理器是实现了<code>InvocationHandler</code>接口的类，该接口只有一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</span><br></pre></td></tr></table></figure>

<p>其中proxy为代理对象，method为当前调用的方法，args 为方法所有参数</p>
<p><strong>代理器中需要持有目标对象（被调用者）的句柄</strong>，一般来说，完成代理需要的任何目标对象，都要储存在调用处理器中，换句话说，目标对象。调用处理器的写法可以参考：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceHandle</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">	<span class="comment">// 这个就是目标对象</span></span><br><span class="line">	<span class="keyword">private</span> Integer target;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 初始化目标对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TraceHandle</span><span class="params">(<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 预处理</span></span><br><span class="line">	    System.out.print(target);</span><br><span class="line">	    System.out.print(<span class="string">&quot;.&quot;</span> + method.getName + <span class="string">&quot;(&quot;</span>);</span><br><span class="line">	    <span class="keyword">if</span>(args != <span class="keyword">null</span>)&#123;</span><br><span class="line">	    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; args.length; i++)&#123;</span><br><span class="line">	    		System.out.print(args[i]);</span><br><span class="line">	    		<span class="keyword">if</span>(i &lt; args.lengthv - <span class="number">1</span>)</span><br><span class="line">	    			System.out.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">	    	&#125;</span><br><span class="line">	    	System.out.print(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">        <span class="comment">// 调用真正的对象（被调用者）相应的方法</span></span><br><span class="line">	    <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口中所有的方法都是需要被代理对象截拦的方法。<strong>对所有接口方法的调用都会转为调用代理对象的invoke()。</strong></p>
<p>注意提供给Proxy类的接口可以有多个，newProxyInstance()中第二个参数也是提供一个数组，当提供多个接口时，<strong>接口的顺序就很关键</strong>，如果<strong>存在两个或多个接口具有相同的方法，则默认以靠前的接口的方法进行调用。</strong></p>
<h3 id="Proxy类"><a href="#Proxy类" class="headerlink" title="Proxy类"></a>Proxy类</h3><p><strong>Proxy类负责生成代理对象</strong>，需要关注的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法生成代理对象。</p>
<p><strong>Proxy类中只有一个InvocationHandler实例字段对象，用于处理所有的方法调用的截拦。</strong></p>
<p>生成代理可以参考：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="keyword">new</span> Object[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++)&#123;</span><br><span class="line">	Integer value = i + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">var</span> handler = <span class="keyword">new</span> TraceHandler(value);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//!!!!</span></span><br><span class="line">	Object proxy = Proxy.newProxyInstance(</span><br><span class="line">		ClassLoader.getSystemClassLoader(),</span><br><span class="line">		<span class="keyword">new</span> Class[] &#123;Comparable.class&#125;,</span><br><span class="line">		handler</span><br><span class="line">	);</span><br><span class="line">	<span class="comment">// 也可以这样写</span></span><br><span class="line">	Comparable proxy = (Comparable)Proxy.newProxyInstance(</span><br><span class="line">		ClassLoader.getSystemClassLoader(),</span><br><span class="line">		<span class="keyword">new</span> Class[] &#123;Comparable.class&#125;,</span><br><span class="line">		handler</span><br><span class="line">	);</span><br><span class="line">	elements[i] = proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特别注意，对于一个特定的类加载器和预设的一组接口来说，只能有一个代理类，换句话说如果对同一个类加载器和接口调用多次newProxyInstance()，只会得到同一个代理类的多个代理对象</strong></p>
<p>如果想要获取代理对象的代理类，可以使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt; …interfaces)</span><br></pre></td></tr></table></figure>

<p><strong>代理类总是<code>public</code>和<code>final</code>的，如果代理类实现的所有接口都是<code>public</code>的，这个代理类就不属于任何特定的包，否则，所有的非<code>public</code>接口都必须要在同一个包，而且生成的代理类也会在这个包中。</strong></p>
<p>可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span></span>;</span><br></pre></td></tr></table></figure>

<p>判断一个类是否为代理类。</p>
<h3 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h3><p><strong>所有的代理类都要扩展Proxy类，同时实现提供给Proxy类的所有接口</strong>，<strong>这些代理类在运行时通过反射被生成，如果没有定义代理类名字，Oracle虚拟机对所有扩展了Proxy类的代理类赋予 <code>$Proxy</code>开头的类名。</strong>因为Proxy类中有唯一的InvocationHandler实例字段，并且这个字段是protected的，<strong>这个实例字段在使用newProxyInstance()时会对其赋值</strong>。</p>
<p><strong>所有代理类都要覆盖Object类中的toString()、equals()、hashCode()，和接口上的方法一样，对这些方法的调用都会引发对invoke()的调用</strong>，Object类的其他方法没有被覆盖。</p>
<h2 id="完整代码解析动态代理过程"><a href="#完整代码解析动态代理过程" class="headerlink" title="完整代码解析动态代理过程"></a>完整代码解析动态代理过程</h2><p>将上面的代码进行综合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">var</span> proxys = <span class="keyword">new</span> Object[<span class="number">1000</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++)&#123;</span><br><span class="line">			Integer value = i + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">			<span class="keyword">var</span> handler = <span class="keyword">new</span> TraceHandler(value);</span><br><span class="line">		</span><br><span class="line">			<span class="comment">//!!!!</span></span><br><span class="line">			Object proxy = Proxy.newProxyInstance</span><br><span class="line">            (</span><br><span class="line">				ClassLoader.getSystemClassLoader(),</span><br><span class="line">				<span class="keyword">new</span> Class[] &#123;Comparable.class&#125;,</span><br><span class="line">				handler</span><br><span class="line">			);</span><br><span class="line">       </span><br><span class="line">			proxys[i] = proxy;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> key = <span class="number">56</span>;</span><br><span class="line">        <span class="keyword">int</span> result = Arrays.binarySearch(proxys, key);</span><br><span class="line">        <span class="keyword">if</span>(result &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(proxys[result]);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceHandle</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">	<span class="comment">// 储存数据</span></span><br><span class="line">	<span class="keyword">private</span> Integer target;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TraceHandle</span><span class="params">(<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 预处理</span></span><br><span class="line">	    System.out.print(target);</span><br><span class="line">	    System.out.print(<span class="string">&quot;.&quot;</span> + method.getName + <span class="string">&quot;(&quot;</span>);</span><br><span class="line">	    <span class="keyword">if</span>(args != <span class="keyword">null</span>)&#123;</span><br><span class="line">	    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; args.length; i++)&#123;</span><br><span class="line">	    		System.out.print(args[i]);</span><br><span class="line">	    		<span class="keyword">if</span>(i &lt; args.lengthv - <span class="number">1</span>)</span><br><span class="line">	    			System.out.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">	    	&#125;</span><br><span class="line">	    	System.out.print(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">        <span class="comment">// 调用真正的对象（被调用者）相应的方法</span></span><br><span class="line">	    <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码实现了在1-1000中使用二分查找找到56！</p>
<p>看上面的代码，首先创建一个proxys代理对象数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxys = <span class="keyword">new</span> Object[<span class="number">1000</span>];</span><br></pre></td></tr></table></figure>

<p>然后生成一个调用处理器，并且传入被调用的对象（数据）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer value = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> handler = <span class="keyword">new</span> TraceHandler(value);</span><br></pre></td></tr></table></figure>

<p>由于Integer类实现了Comparable接口，因此创建一个实现了Comparable，同时使用TraceHandler作为调用处理器的代理对象proxy：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object proxy = Proxy.newProxyInstance</span><br><span class="line">            (</span><br><span class="line">				ClassLoader.getSystemClassLoader(),</span><br><span class="line">				<span class="keyword">new</span> Class[] &#123;Comparable.class&#125;,</span><br><span class="line">				handler</span><br><span class="line">			);</span><br></pre></td></tr></table></figure>

<p>然后将代理对象存储在代理对象数组中。</p>
<p>接下来真正的动态代理过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> key = <span class="number">56</span>;</span><br><span class="line"><span class="keyword">int</span> result = Arrays.binarySearch(proxys, key);</span><br><span class="line"><span class="keyword">if</span>(result &gt; <span class="number">0</span>)&#123;</span><br><span class="line">	System.out.println(proxys[result]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> proxys数组中的每一个元素都是一个代理对象，之前已经有提到，一个代理类中有唯一的<code>InvocationHandler</code>实例字段，<strong>这个实例字段在调用newProxyInstance()时会对其赋值</strong>。因此对于每一个代理对象，都会有一个<code>handle</code>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var handler = new TraceHandler(value);</span><br></pre></td></tr></table></figure>

<p><strong>binarySearch()里面会调用compareTo()<strong>，</strong>由于代理对象实现了Comparable接口</strong>，因此binarySearch()内部将会调用代理对象的compareTo()，上面也提到过，<strong>对所有接口方法的调用都会转为调用代理对象的invoke()，因此代理对象的compareTo()将会调用invoke()<strong>，</strong>同时把代理对象自身（this），将compareTo()封装为Method对象，把所有compareTo()方法的参数储存在Object[]，并将这三个信息传递给invoke()。</strong></p>
<p>在invoke()里面，通过使用Method对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method.invoke(target, args);</span><br><span class="line"><span class="comment">// 注意这个invoke是method对象的invoke，不是TraceHandler的invoke</span></span><br></pre></td></tr></table></figure>

<p>来调用真正的compareTo()。</p>
<p>还记得我们是如何声明TraceHandler的吗？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer value = i + 1;</span><br><span class="line">var handler = new TraceHandler(value);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceHandle</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">	<span class="comment">// 储存数据</span></span><br><span class="line">	<span class="keyword">private</span> Integer target;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TraceHandle</span><span class="params">(<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>value就是target哦</strong>！！！对于代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method.invoke(target, args);</span><br></pre></td></tr></table></figure>

<p>由于compareTo()只有一个参数，因此args数组只有一个成员，上面的代码就相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">target.compareTo(args[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 实际上就是：</span></span><br><span class="line">value.compareTo(args[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>对于这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(result &gt; <span class="number">0</span>)&#123;</span><br><span class="line">	System.out.println(proxys[result]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实也是一样，先调用<code>proxys[result]</code>的<code>toString()</code>,<code>toString()</code>会调用代理处理器<code>handler</code>的<code>invoke() </code>在<code>invoke() </code>里面，会调用<code>method.invoke(target, args);</code>由于<code>toString()</code>没有参数，因此<code>method.invoke(target, args);</code>相当于<code>method.invoke(target, null)</code>，相当于<code>target.toString()</code>也就是<code>value.toString()</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/09/09/Java/Java%E4%BB%A3%E7%90%86/image-20210902222620840.png" alt="image-20210902222620840"></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><strong>调用newProxyInstance()只传递了一个接口时，那么就要要求目标对象实际上也是实现了这个接口的类所产生的对象</strong>，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object proxy = Proxy.newProxyInstance</span><br><span class="line">            (</span><br><span class="line">				ClassLoader.getSystemClassLoader(),</span><br><span class="line">				<span class="keyword">new</span> Class[] &#123;Comparable.class&#125;,</span><br><span class="line">				handler</span><br><span class="line">			);</span><br></pre></td></tr></table></figure>

<p>那么<strong>调用处理器内的目标对象句柄也要实现Comparable</strong>，在TraceHandle类中，他内部的目标对象是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer value = i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Integer类本身就实现了Comparable。</strong>因此在进行<code>method.invoke(target, args)</code>才可以通过，否则会报<code>MethodNotFoundException</code></p>
<p><strong>如果调用newProxyInstance()传递了多个接口，那么对于目标对象就需要实现其中至少一个接口，这个时候的关键点其实不在目标对象而在调用处理器invoke()的编写。</strong></p>
<p>在这情况下<strong>，调用处理器中所有目标对象总共实现的所有接口应要包含传递给newProxyInstance()的多个接口</strong></p>
<h2 id="动态代理用途"><a href="#动态代理用途" class="headerlink" title="动态代理用途"></a>动态代理用途</h2><ol>
<li>对目标对象的方法每次被调用，进行动态拦截。</li>
<li>代理处理器可以储存多个目标对象，在invoke内部，可以根据不同的method，使用不同的目标对象。</li>
<li>对接口方法进行预处理（增强方法）</li>
</ol>
]]></content>
      <categories>
        <category>java学习笔记</category>
      </categories>
      <tags>
        <tag>java_core</tag>
        <tag>java_lib</tag>
      </tags>
  </entry>
  <entry>
    <title>Java正则表达式</title>
    <url>/2021/08/13/Java/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式并非是Java固有，几乎每一门语言都有，正则表达式在匹配字符串，字符串搜索和模式匹配上一直发挥着重要的作用，因此学习正则表达式非常有必要</p>
<p>针对<code>java</code>语言，我打算出一些语言的核心知识和一些类库的使用，还有自己翻译的API，都会放在博客里面供参考。</p>
<p>各位有需要可以在tags那里点击所有以<code>java</code>开头的标签，这些标签的意义如下：</p>
<ul>
<li>java_core：核心的java知识，包括反射、泛型、注解、代理……</li>
<li>java_lib：各类java类库的使用基础，java的API，或者一些API的历史</li>
<li>java_features：java的特性，包括java的语法糖，java各版本的更新特性等</li>
<li>……</li>
</ul>
<p>常用正则表达式：<a href="https://www.argentoaskia.tech/2021/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#more">点击这里</a></p>
<span id="more"></span>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>表达式一般以<code>/../</code>来标记为正则表达式</p>
<h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p><code>[abc]</code>:匹配a、b、c中的一个字符</p>
<p><code>[^abc]</code>：匹配除了a、b、c之外的所有字符</p>
<p><code>[A-Z]</code>：[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</p>
<p><code>.</code>：匹配除换行符（\n、\r）之外的任何单个字符，相等于<code>[^\n\r]</code></p>
<p><code>[\s\S]</code>：匹配所有。</p>
<p><code>[\w]</code>：匹配字母、数字、下划线。等价于 <code>[A-Za-z0-9_]</code></p>
<p><code>\W</code>：匹配非字母、数字、下划线</p>
<p><code>\d</code>：匹配一个数字字符。</p>
<p><code>\D</code>：匹配一个非数字字符。</p>
<h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\cx</td>
<td align="left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody></table>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>所谓特殊字符，就是一些有特殊含义的字符，如果需要该字符的原意思，则需要加上<code>\</code></p>
<table>
<thead>
<tr>
<th align="left">特别字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$</td>
<td align="left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 <code>\$</code>。</td>
</tr>
<tr>
<td align="left">( )</td>
<td align="left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 <code>\(</code> 和 <code>\)</code>。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 <code>\*</code>。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 <code>\+</code>。</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 <code>\.</code> 。</td>
</tr>
<tr>
<td align="left">[</td>
<td align="left">标记一个中括号表达式的开始。要匹配 [，请使用 <code>\[</code>。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 <code>\?</code>。</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 <code>\^</code>。</td>
</tr>
<tr>
<td align="left">{</td>
<td align="left">标记限定符表达式的开始。要匹配 {，请使用 <code>\&#123;</code>。</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">指明两项之间的一个选择。要匹配 |，请使用 <code>|</code>。</td>
</tr>
</tbody></table>
<p><strong>*<strong>和 <strong>+</strong> 限定符都是贪婪的，</strong>因为它们会尽可能多的匹配文字</strong>，只有在它们的后面加上一个 <strong>?</strong> 就可以实现非贪婪或最小匹配。</p>
<p><img src="/2021/08/13/Java/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20210310222706753.png" alt="image-20210310222706753"></p>
<p><img src="/2021/08/13/Java/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20210310222754435.png" alt="image-20210310222754435"></p>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^</td>
<td align="left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">匹配一个单词边界，即字与空格间的位置。加上该字符代表单词结束或者开始位置</td>
</tr>
<tr>
<td align="left">\B</td>
<td align="left">非单词边界匹配。</td>
</tr>
</tbody></table>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><img src="/2021/08/13/Java/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20210310223659729.png" alt="image-20210310223659729"></p>
<p><img src="/2021/08/13/Java/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20210310223717605.png" alt="image-20210310223717605"></p>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>用圆括号 <strong>()</strong> 将所有选择项括起来，相邻的选择项之间用 <strong>|</strong> 分隔。</p>
<p><img src="/2021/08/13/Java/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20210310224311818.png" alt="image-20210310224311818"></p>
<h2 id="先行断言和后行断言"><a href="#先行断言和后行断言" class="headerlink" title="先行断言和后行断言"></a>先行断言和后行断言</h2><ul>
<li>**exp1(?=exp2)**：查找 exp2 前面的 exp1。</li>
<li><strong>(?&lt;=exp2)exp1</strong>：查找 exp2 后面的 exp1。</li>
<li>**exp1(?!exp2)**：查找后面不是 exp2 的 exp1。</li>
<li><strong>(?&lt;!exp2)exp1</strong>：查找前面不是 exp2 的 exp1。</li>
</ul>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/03/reg-111.jpg" alt="img"></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/03/reg-222.jpg" alt="img"></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/03/reg-333.jpg" alt="img"></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/03/reg-444.jpg" alt="img"></p>
<h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>对一个正则表达式模式或部分模式两边添加<code>()</code>将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 <strong>\n</strong> 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。例如表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(\d&#123;4&#125;)-(\d&#123;2&#125;-(\d\d))</span><br></pre></td></tr></table></figure>

<p>那么临时缓冲区中捕获组就是：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>捕获组</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>(\d{4})-(\d{2}-(\d\d))</td>
</tr>
<tr>
<td>1</td>
<td>(\d{4})</td>
</tr>
<tr>
<td>2</td>
<td>(\d{2}-(\d\d))</td>
</tr>
<tr>
<td>3</td>
<td>(\d\d)</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">([a-z][a-z])\1&#123;2&#125;</span><br><span class="line">([a-z][a-z])([a-z][a-z])\2</span><br><span class="line"></span><br><span class="line">target：aaaaaassawsaaaddddddssssssasssdwsssdasadawswewewe</span><br></pre></td></tr></table></figure>

<p>对于上面的表达式的捕获组处理是：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>捕获组</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>([a-z][a-z])\1{2}</td>
</tr>
<tr>
<td>1</td>
<td>([a-z][a-z])</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>编号</th>
<th>捕获组</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>([a-z][a-z])([a-z][a-z])\2</td>
</tr>
<tr>
<td>1</td>
<td>([a-z][a-z])</td>
</tr>
<tr>
<td>2</td>
<td>([a-z][a-z])</td>
</tr>
</tbody></table>
<p>对于表达式1：</p>
<p>([a-z][a-z])：括号表达式要求匹配两个字符，例如：aa。</p>
<p>\1{2}：反向引用捕获组编号为1的表达式当前的值2次，如果有匹配的则输出，没有匹配则设置捕获组1的下一次的值，如([a-z][a-z])匹配了aa之后，读到\1{2}时是匹配aa值两次，因此后面匹配aaaa，刚好后面有4个a，因此，匹配成功，输出：aaaaaa。（匹配ABABAB的结果，其中A，B为任意字符，并且可以相同），下面为整个表达式的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaaaaa</span><br><span class="line">dddddd</span><br><span class="line">ssssss</span><br><span class="line">wewewe</span><br></pre></td></tr></table></figure>

<p>对于表达式2：</p>
<p>第一个([a-z][a-z])：括号表达式要求匹配两个字符，例如：aa。</p>
<p>第二个([a-z][a-z])：括号表达式要求匹配两个字符，例如：aa。</p>
<p>\2：反向引用捕获组编号为2的表达式当前值一次，为：aa</p>
<p>因此该表达式将匹配aaaaaa（匹配XXABAB的结果，其中X、A、B为任意字符）下面为整个表达式的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaaaaa</span><br><span class="line">aadddd</span><br><span class="line">ddssss</span><br><span class="line">wswewe</span><br></pre></td></tr></table></figure>

<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>在开篇有讲到，一般的正则表达式都是以<code>/.../</code>开头，实际上真正的格式应该是下面这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/pattern/flags</span><br></pre></td></tr></table></figure>

<ul>
<li>pattern：代表表达式</li>
<li>flags：代表标志，常用的标志有3个（实际上有4个）</li>
</ul>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>含义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>ignore-不区分大小写</td>
<td>匹配将不区分大小写</td>
</tr>
<tr>
<td>g</td>
<td>global-全局匹配</td>
<td>默认表达式匹配到一个即停止，加上该修饰符将匹配所有匹配项</td>
</tr>
<tr>
<td>m</td>
<td>multi line - 多行匹配</td>
<td>使边界字符 <strong>^</strong> 和 <strong>$</strong> 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td>
</tr>
<tr>
<td>s</td>
<td>特殊字符圆点 <strong>.</strong> 中包含换行符 \n</td>
<td>默认情况下的圆点 <strong>.</strong> 是 匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 <strong>s</strong> 修饰符之后, <strong>.</strong> 中包含换行符 \n。</td>
</tr>
</tbody></table>
<p>其他的都比较简单，这里只说明m的用途</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2020/08/BC3E6D8A-21D2-44F8-A1AE-D90C4939D37A.jpg" alt="img"></p>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p><img src="/2021/08/13/Java/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20210311182844145.png" alt="image-20210311182844145"></p>
]]></content>
      <categories>
        <category>java学习笔记</category>
      </categories>
      <tags>
        <tag>java_features</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/2021/08/12/Java/Java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>Java泛型，<code>java</code>语言的核心知识之一，各大框架经常使用的技术。</p>
<p>针对<code>java</code>语言，我打算出一些语言的核心知识和一些类库的使用，还有自己翻译的API，都会放在博客里面供参考。</p>
<p>各位有需要可以在tags那里点击所有以<code>java</code>开头的标签，这些标签的意义如下：</p>
<ul>
<li>java_core：核心的java知识，包括反射、泛型、注解、代理……</li>
<li>java_lib：各类java类库的使用基础，java的API，或者一些API的历史</li>
<li>java_features：java的特性，包括java的语法糖，java各版本的更新特性等</li>
<li>……</li>
</ul>
<span id="more"></span>

<h2 id="早期泛型"><a href="#早期泛型" class="headerlink" title="早期泛型"></a>早期泛型</h2><p>在设计集合类时，<strong>为了能够兼容任何数据，早期的集合类装载数据使用的是<code>Object</code>类型</strong>，<strong>然后获取数据的时候通过强制类型转换来转为具体数据</strong>。这种方法非常不方便而且容易造成<code>InvalidCastException</code>，因此Java设计者引入了泛型概念。</p>
<h2 id="泛型定义"><a href="#泛型定义" class="headerlink" title="泛型定义"></a>泛型定义</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>一个简单的泛型类可以如下定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Road</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T begin;</span><br><span class="line">    <span class="keyword">private</span> T end;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBegin</span><span class="params">(T data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">(T data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getBegin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getEnd</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述定义的为含有一个泛型类型<code>T</code>的类<code>Road</code>，也可以定义多个泛型类型<code>K,V</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> K key;</span><br><span class="line">	<span class="keyword">private</span> V value;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(K <span class="keyword">var</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V <span class="keyword">var</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用泛型类也很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;String, String&gt; node = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">Road&lt;Integer&gt; westRoad = <span class="keyword">new</span> Road&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>需要注意一点，Java泛型不支持基本类型，也就是说想要传递基本类型的泛型，请使用包装类</strong></p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(T subIndex)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意泛型类型限定在修饰符之后，返回值之前</strong>，也就是在<code>public static之后</code></p>
<p>调用的时候，只需要指定类型即可。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c.&lt;String&gt;get(2);</span><br></pre></td></tr></table></figure>

<p>然而编译器在有些时候是可以自动识别泛型参数类型，对于第二个方法而言，可以这样调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">c.get(<span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编译器会自动识别参数类型，从而将识别的类型”替换”掉T。例如，由于传进的参数<code>subIndex</code>是一个<code>String</code>，因此<code>T</code>被”替换”成<code>String</code>，方法变成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(String subIndex)</span></span>;</span><br></pre></td></tr></table></figure>

<p><del>（我知道实际并不是这样的，但是请先按照这样理解，谢谢）</del></p>
<h2 id="泛型限定"><a href="#泛型限定" class="headerlink" title="泛型限定"></a>泛型限定</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Road</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T begin;</span><br><span class="line">    <span class="keyword">private</span> T end;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBegin</span><span class="params">(T data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">(T data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getBegin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getEnd</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义这样的泛型，意味着我可以<strong>实例化任何类型的该泛型</strong>，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Road&lt;Integer&gt; westRoad1 = <span class="keyword">new</span> Road&lt;&gt;();</span><br><span class="line">Road&lt;String&gt; westRoad2 = <span class="keyword">new</span> Road&lt;&gt;();</span><br><span class="line">Road&lt;Double&gt; westRoad3 = <span class="keyword">new</span> Road&lt;&gt;();</span><br><span class="line">Road&lt;Float&gt; westRoad4 = <span class="keyword">new</span> Road&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>这些实例化都是合法的，但是实际上我们对于一段路的描述，应该是限定为字符串，因此只有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Road&lt;String&gt; westRoad2 = <span class="keyword">new</span> Road&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>是符合实际的，那有没有方法将泛型类型限定在只能是<code>String</code>，或者是它的子类呢？有，使用<strong>泛型类型限定</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Road</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">String</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样只有是<code>String</code>类型或者是它的子类才能够作为泛型类型。限定的语法是<code>&lt;T extends class&gt;</code>。</p>
<p>同时Java支持多限定，每个<code>class</code>之间使用<code>&amp;</code>分隔</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Road</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">String</span> &amp; <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>但注意，多限定中最多只能有一个类级限定，其他都是接口限定，并且该类级限定必须放在第一位。</strong>如下会报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">class</span> <span class="title">Road</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">String</span> &amp; <span class="title">Integer</span>&gt;	// <span class="title">compile</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><h3 id="何为泛型擦除"><a href="#何为泛型擦除" class="headerlink" title="何为泛型擦除"></a>何为泛型擦除</h3><p>首先，虚拟机中没有泛型类型，只有普通方法和类。因此所有的泛型类最终都会被擦除为普通类，擦除的方法是<strong>使用<span style="background-color:yellow">第一个限定类型</span>代替泛型类型，若无限定类型则擦除为Object</strong>，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Road&lt;T extends String &amp; Comparable&lt;T&gt;&gt;&#123;</span><br><span class="line"> 	private T begin;</span><br><span class="line">    private T end;</span><br><span class="line">    public void setBegin(T data);</span><br><span class="line">    public void setEnd(T data);</span><br><span class="line">    public T getBegin();</span><br><span class="line">    public T getEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>擦除后，就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Road&#123;</span><br><span class="line"> 	private String begin;</span><br><span class="line">    private String end;</span><br><span class="line">    public void setBegin(String data);</span><br><span class="line">    public void setEnd(String data);</span><br><span class="line">    public String getBegin();</span><br><span class="line">    public String getEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，实际的类模板应该是后者而不是泛型类。</p>
<h3 id="实现类型转换"><a href="#实现类型转换" class="headerlink" title="实现类型转换"></a>实现类型转换</h3><p>既然实际上生成的模板类是后者，那么对于实例化的泛型类，是怎样返回目标类型数据的呢？比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Road&lt;SimpleStringType&gt; road = <span class="keyword">new</span> Road&lt;&gt;();</span><br><span class="line"><span class="comment">// SimpleStringType 继承于 String</span></span><br></pre></td></tr></table></figure>

<p>那么类型擦除之后，是怎样保证返回的是<code>SimpleStringType</code>类型而不是<code>String</code>呢？实际上java沿用的还是老办法——<strong>类型强制转换</strong>，只不过这个转换过程由虚拟机完成。例如：</p>
<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleStringType sim = road.getBegin();</span><br></pre></td></tr></table></figure>

<p>实际上虚拟机做的是两件事：</p>
<ul>
<li>调用<code>getBegin()</code></li>
<li>为返回类型方法插入强制类型转换指令</li>
</ul>
<h3 id="桥方法"><a href="#桥方法" class="headerlink" title="桥方法"></a>桥方法</h3><p>首先这里有几个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T data)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">local</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">LocalDate</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在的调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">local l = <span class="keyword">new</span> local();</span><br><span class="line">Pair&lt;LocalDate&gt; p = l;	<span class="comment">// 合法的，因为有继承关系</span></span><br><span class="line">p.setSecond();</span><br></pre></td></tr></table></figure>

<p>那么会调用哪个方法呢？是<code>local</code>类中的还是<code>Pair</code>类中的。</p>
<p>根据多态特性，应该是要调用<code>local</code>类中的<code>setSecond()</code>，但实际上并非如此，因为<code>local</code>类中<code>setSecond()</code>和<code>Pair</code>类中的<code>setSecond()</code>并非是重写关系，而是重载，因为<code>Pair</code>类擦除为普通类之后，<code>setSecond()</code>是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object data)</span></span>;</span><br></pre></td></tr></table></figure>

<p>但是，这与我们需求的期望不相同，我们期望的是他们之间是一个多态的、关系，并且考虑到调用方式，他们应该是同一个方法。然而重载关系没法实现多态（因为实现多态必须是重写关系），那么如何简单地解决这个问题呢，java设计者引入了<strong>桥方法</strong>：即在<code>local</code>类中增加一个擦除类型对应的<code>setSecond</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">local</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">LocalDate</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object <span class="keyword">var</span>)</span></span>&#123;</span><br><span class="line">        setSecond( (LocalDate)<span class="keyword">var</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以保证重写。实现多态。</p>
<h2 id="限制和注意点"><a href="#限制和注意点" class="headerlink" title="限制和注意点"></a>限制和注意点</h2><h3 id="不能用基本类型实例化类型参数"><a href="#不能用基本类型实例化类型参数" class="headerlink" title="不能用基本类型实例化类型参数"></a>不能用基本类型实例化类型参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;<span class="keyword">double</span>&gt; doublePair;		<span class="comment">// (x)</span></span><br><span class="line">Pair&lt;Double&gt; doublePair;	`	<span class="comment">// (√)</span></span><br><span class="line"><span class="comment">//原因参考类型擦除</span></span><br></pre></td></tr></table></figure>

<h3 id="运行时类型查询只适用于原始类型"><a href="#运行时类型查询只适用于原始类型" class="headerlink" title="运行时类型查询只适用于原始类型"></a>运行时类型查询只适用于原始类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; stringPair = ...;</span><br><span class="line">Pair&lt;Employee&gt; employeePair = ...;</span><br><span class="line"><span class="keyword">if</span>(stringPair.getClass() == employeePair.getClass())	<span class="comment">// return: true</span></span><br></pre></td></tr></table></figure>

<p>原因是<code>getClass()</code>返回的是原始类型，都是<code>Pair.class</code>。</p>
<h3 id="不能创建参数化类型的数组"><a href="#不能创建参数化类型的数组" class="headerlink" title="不能创建参数化类型的数组"></a>不能创建参数化类型的数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>];	<span class="comment">// (x)</span></span><br></pre></td></tr></table></figure>

<p>类型擦除之后，<code>table</code>的类型是<code>Pair[]</code>，这样的擦除对于<code>Pair&lt;Employee&gt;</code>、<code>Pair&lt;Integer&gt;</code>都成立，换句话说<code>table</code>变量<strong>既可以存储<code>Pair&lt;String&gt;</code>值，也可以存储<code>Pair&lt;Employee&gt;</code>、<code>Pair&lt;Integer&gt;</code><strong>，</strong>这破坏了java数组会记住它的元素类型的机制</strong></p>
<p>当然，可以创建<code>Pair&lt;String&gt;[]</code>这样的变量（<strong>为了支持方法中可变参数的使用</strong>，而放宽的特例），<strong>只是不能用<code>new</code>实例化</strong>，如果真的需要用到这类型的数组，<strong>请使用<code>ArrayList</code>等容器类！</strong></p>
<h3 id="不能实例化类型变量"><a href="#不能实例化类型变量" class="headerlink" title="不能实例化类型变量"></a>不能实例化类型变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T First = <span class="keyword">new</span> T();		<span class="comment">// (x)</span></span><br></pre></td></tr></table></figure>

<p>类型擦除之后就是<code>Object</code>（假设<code>&lt;T extends Object&gt;</code>），注意：在下面方法中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; void printClass(T a)&#123;</span><br><span class="line">	T.class			//(x)</span><br><span class="line">	a.getClass()	// 假设提供的a是String类型则返回class java.lang.String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>a.getClass()</code>虽然会获取到<code>String</code>类型，但是无法用于反射调用构造新对象。也就是说，下面的代码都会报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a.getClass().getConstructor().newInstance();	<span class="comment">//(x)</span></span><br><span class="line">T.class..getConstructor().newInstance();		<span class="comment">//(x)</span></span><br></pre></td></tr></table></figure>

<p>原因参考下图：</p>
<p><img src="/2021/08/12/Java/Java%E6%B3%9B%E5%9E%8B/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4.png" alt="类型擦除"></p>
<p>泛型变量会被标记为一个虚拟机运行时临时类型<code>CAP#X</code>，而不是<code>String</code>。</p>
<p>当然要真的需要实例化，有两种方法可以解决：</p>
<ul>
<li>增加参数</li>
<li>反射机制</li>
</ul>
<h3 id="不能构造泛型数组"><a href="#不能构造泛型数组" class="headerlink" title="不能构造泛型数组"></a>不能构造泛型数组</h3><h2 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h2><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><h2 id="反射与泛型"><a href="#反射与泛型" class="headerlink" title="反射与泛型"></a>反射与泛型</h2>]]></content>
      <categories>
        <category>java学习笔记</category>
      </categories>
      <tags>
        <tag>java_core</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解</title>
    <url>/2021/08/12/Java/Java%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>Java注解，<code>java</code>语言的核心知识之一，各大框架经常使用的技术。</p>
<p>注解在代码标注、编译提示中都具有非常好的效果，本章将对Java的注解进行简略的介绍。</p>
<p>针对<code>java</code>语言，我打算出一些语言的核心知识和一些类库的使用，还有自己翻译的API，都会放在博客里面供参考。</p>
<p>各位有需要可以在tags那里点击所有以<code>java</code>开头的标签，这些标签的意义如下：</p>
<ul>
<li>java_core：核心的java知识，包括反射、泛型、注解、代理……</li>
<li>java_lib：各类java类库的使用基础，java的API，或者一些API的历史</li>
<li>java_features：java的特性，包括java的语法糖，java各版本的更新特性等</li>
<li>……</li>
</ul>
<span id="more"></span>

<h2 id="关于注解"><a href="#关于注解" class="headerlink" title="关于注解"></a>关于注解</h2><p>Java注解（Annotation），又称之为元数据，通常用于标记代码信息、添加代码标记。Java内置定义了自己的一套内置注解，共7个。</p>
<p>按照分类可以分成：</p>
<h3 id="标识所有内容（代码或注解）："><a href="#标识所有内容（代码或注解）：" class="headerlink" title="标识所有内容（代码或注解）："></a>标识所有内容（代码或注解）：</h3><p>@Documented：标记这些注解是否可以生成在用户文档中（javadoc）</p>
<p>@SuppressWarnings：忽略注解中声明的警告。</p>
<h3 id="与代码相关："><a href="#与代码相关：" class="headerlink" title="与代码相关："></a>与代码相关：</h3><p>@Override：用于标记、检查方法是否是重写方法。</p>
<p>@Deprecated：标记方法为过时方法，使用这一类方法，IDE会在其上面加上删除线。</p>
<h3 id="用于创建、标识其他注解："><a href="#用于创建、标识其他注解：" class="headerlink" title="用于创建、标识其他注解："></a>用于创建、标识其他注解：</h3><p>@Retention：标识这个注解如何保存，有三种方式。</p>
<p>@Target：标记这个注解是哪种Java类型（属性、方法、类…）</p>
<p>@Inherited：标记注解继承于哪个注解类</p>
<blockquote>
<p>Java 7、8以后额外添加了三个：@SafeVarargs、@FunctionalInterface、@Repeatable</p>
<p>@Repeatable：标识某注解可以在同一个声明上使用多次。</p>
<p>@FunctionalInterface：标识一个匿名函数或者函数式接口</p>
<p>@SafeVarargs：忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。通常用在泛型数组。</p>
</blockquote>
<h2 id="注解组成部分"><a href="#注解组成部分" class="headerlink" title="注解组成部分"></a>注解组成部分</h2><p>一个注解的定义可以由两部分组成：<strong>1-n个</strong><code>ElementType</code>（作用对象）和<strong>1种</strong><code>RetentionPolicy</code>（存储方式）。</p>
<p><img src="/2021/08/12/Java/Java%E6%B3%A8%E8%A7%A3/6.jpg" alt="6"></p>
<p><code>ElementType</code>主要有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span></span>&#123;</span><br><span class="line">	TYPE,					<span class="comment">// 类、接口、枚举</span></span><br><span class="line">	FIELD,					<span class="comment">// 字段、枚举常量</span></span><br><span class="line">	METHOD,					<span class="comment">// 方法</span></span><br><span class="line">	PARAMETER,				<span class="comment">// 方法参数</span></span><br><span class="line">	CONSTRUCTOR,			<span class="comment">// 构造方法</span></span><br><span class="line">	LOCAL_VARIABLE,			<span class="comment">// 局部变量</span></span><br><span class="line">	ANNOTATION_TYPE,		<span class="comment">// 注解类型</span></span><br><span class="line">	PACKAGE,				<span class="comment">// 包</span></span><br><span class="line">	TYPE_PARAMETER,			<span class="comment">// catch参数</span></span><br><span class="line">	TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RetentionPolicy</code>主要有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span> </span>&#123;</span><br><span class="line">    SOURCE,            <span class="comment">// Annotation信息仅存在于编译器处理期间，编译器编译成class文件的时候，注解被遗弃。</span></span><br><span class="line"></span><br><span class="line">    CLASS,             <span class="comment">// 编译器将Annotation存储于类对应的.class文件中，但在jvm加载类的时候被遗弃，默认行为。 </span></span><br><span class="line"></span><br><span class="line">    RUNTIME            <span class="comment">// 编译器将Annotation存储于class文件中，并且在jvm加载类的时候，仍然存在。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>想要自定义注解，首先要了解注解的接口<code>Annotation</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口的具体实现由编译器完成，编译器实现该接口提供<code>@interface</code>注解用于创建新注解。这与通常的<code>implement</code>接口不太一样。</p>
<p>创建过程中，需要指定注解的<strong>两个组成部分</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.FIELD, ELementType.METHOD)</span>	<span class="comment">// 指定该注解的作用范围</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>				<span class="comment">// 指定注解保存形式</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Overload&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;func1&quot;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>@interface</code>定义这是一个注解，是必须的。</p>
<p><code>@Target</code>用于指定该注解作用与哪些对象上。</p>
<p><code>@Retention</code>用于指定注解储存方式，有默认值CLASS，可选的。</p>
<h2 id="内置注解类"><a href="#内置注解类" class="headerlink" title="内置注解类"></a>内置注解类</h2><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Override</code>注解的触发，最常用的就是标注方法为重写方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般建议是在有重写的地方就标上<code>@Override</code>，会有好处的！</p>
<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">    <span class="function">String <span class="title">since</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;				<span class="comment">// 从哪个版本开始废弃</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">forRemoval</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>@Deprecated</code>标记的方法，在被使用时会被加上删除线</strong>，可以加参数，第一个参数用来标明该对象在何时开始被弃用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="meta">@Deprecated(&quot;1.5&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Documented &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标记这个注解可以被javadoc处理。</p>
<h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inherited &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标注该注解对于子类也是可见的(存在继承关系)，子类可以通过反射来获取父类的注解类。</p>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repeatable &#123;</span><br><span class="line">    Class&lt;? extends Annotation&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个注解用于忽略某些警告，有对应的可选项：参数Value可以填入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deprecation  -- 使用了不赞成使用的类或方法时的警告</span><br><span class="line">unchecked    -- 执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。</span><br><span class="line">fallthrough  -- 当 Switch 程序块直接通往下一种情况而没有 Break 时的警告。</span><br><span class="line">path         -- 在类路径、源文件路径等中有不存在的路径时的警告。</span><br><span class="line">serial       -- 当在可序列化的类上缺少 serialVersionUID 定义时的警告。</span><br><span class="line">finally      -- 任何 finally 子句不能正常完成时的警告。</span><br><span class="line">all          -- 关于以上所有情况的警告。</span><br></pre></td></tr></table></figure>

<h3 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="line">public @interface Repeatable &#123;</span><br><span class="line">    Class&lt;? extends Annotation&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs"></a>@SafeVarargs</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD&#125;)</span><br><span class="line">public @interface SafeVarargs &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在声明具有<strong>模糊类型（比如：泛型）的可变参数的构造函数或方法时</strong>，Java编译器会报unchecked警告。鉴于这些情况，如果程序员断定声明的构造函数和方法的主体不会对其varargs参数执行潜在的不安全的操作，可使用@SafeVarargs进行标记，这样的话，Java编译器就不会报unchecked警告</p>
<p><strong>@SafeVarargs注解，对于非static或非final声明的方法，不适用，会编译不通过，对于非static或非final声明的方法，请使用@SuppressWarnings(“unchecked”)</strong></p>
<h3 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface FunctionalInterface &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>用于标注只含有一个抽象方法的函数接口</p>
<h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2><p>注解可以用于编译检查，帮助阅读代码（Override）、生成帮助文档等。其中最为频繁的使用方式，就是下面要介绍的这个，很多大型框架中的注解的原理就跟下面类似。</p>
<h3 id="使用反射机制获取注解内容"><a href="#使用反射机制获取注解内容" class="headerlink" title="使用反射机制获取注解内容"></a>使用反射机制获取注解内容</h3>]]></content>
      <categories>
        <category>java学习笔记</category>
      </categories>
      <tags>
        <tag>java_core</tag>
        <tag>java_lib</tag>
        <tag>java_features</tag>
      </tags>
  </entry>
  <entry>
    <title>”Java运行时获取运行位置“</title>
    <url>/2021/08/17/Java/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>获取运行时路径的方法在jar包中和在工程中都不同，下面进行区分讲解</p>
<span id="more"></span>

<h2 id="获取路径"><a href="#获取路径" class="headerlink" title="获取路径"></a>获取路径</h2><p>以下介绍的方法同时适用于jar包和工程中</p>
<p>获取运行时路径的方法很多，这里只介绍一种通用的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ClassName].class.getProtectionDomain().getCodeSource().getLocation();</span><br></pre></td></tr></table></figure>

<p>这种方法在工程中获取的是工程项目的位置，在jar包中是获取jar包所在的位置（包括XXXX.jar）</p>
<h2 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h2><h3 id="class-getResource-String-resourceFile"><a href="#class-getResource-String-resourceFile" class="headerlink" title="class.getResource(String resourceFile)"></a>class.getResource(String resourceFile)</h3><h3 id="class-getClassLoader-getResource-String-resourceFile"><a href="#class-getClassLoader-getResource-String-resourceFile" class="headerlink" title="class.getClassLoader().getResource(String resourceFile)"></a>class.getClassLoader().getResource(String resourceFile)</h3><p>上面的区别看这里：</p>
<p><img src="/2021/08/17/Java/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E4%BD%8D%E7%BD%AE/v2-2023e3d7fdae0160e22a5dedde736368_720w.jpg" alt="img"></p>
<p><img src="/2021/08/17/Java/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E4%BD%8D%E7%BD%AE/v2-33f6acaa7515bb06d292abf9051cb535_720w.jpg" alt="img"></p>
<p><code>class.getResource(String resource)</code> 调用当前类路径下的资源</p>
<p><code>class.getClassLoader().getResource(String resource)</code> 获取跟路径，调用根目录下资源</p>
<p><strong>上面的两种方式在工程项目中有效，在jar包中无效</strong></p>
<h3 id="class-getResourceAsStream-String-resourceFile"><a href="#class-getResourceAsStream-String-resourceFile" class="headerlink" title="class.getResourceAsStream(String resourceFile)"></a>class.getResourceAsStream(String resourceFile)</h3><p>要想在jar包中也能够读取资源文件，请使用这个方法！</p>
]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>java_skill</tag>
      </tags>
  </entry>
  <entry>
    <title>Java重载VS重写</title>
    <url>/2021/08/14/Java/Java%E9%87%8D%E8%BD%BDVS%E9%87%8D%E5%86%99/</url>
    <content><![CDATA[<p>希望这篇文章能够帮助各位重载和重写傻傻分不清的朋友！</p>
<span id="more"></span>

<h2 id="重写（Override）"><a href="#重写（Override）" class="headerlink" title="重写（Override）"></a>重写（Override）</h2><p>重写一般是对父类的方法进行重写，要求</p>
<ul>
<li><strong>返回值和形参都不能改变！</strong></li>
<li><strong>返回值类型可以不相同，但必须是父类返回值的派生类（java 7↑）</strong></li>
<li><strong>重写的方法能够抛出任何非强制性异常，但当父类方法本身也声明抛出的异常的时候，子类异常只能是父类异常的子类</strong></li>
<li><strong>不能缩窄访问权限（父类方法是public，子类重写方法就不能为protected）</strong></li>
<li><strong>声明为<code>final</code>的方法不能被重写</strong></li>
<li><strong>声明为<code>static</code>的方法不能被重写，但是能够被再次声明</strong></li>
<li><strong>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</strong></li>
<li><strong>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</strong></li>
<li><strong>构造方法不能被重写</strong></li>
</ul>
<h2 id="重载（Overload）"><a href="#重载（Overload）" class="headerlink" title="重载（Overload）"></a>重载（Overload）</h2><ul>
<li><strong>被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；</strong></li>
<li><strong>被重载的方法可以改变返回类型；</strong></li>
<li><strong>被重载的方法可以改变访问修饰符；</strong></li>
<li><strong>被重载的方法可以声明新的或更广的检查异常；</strong></li>
<li><strong>方法能够在同一个类中或者在一个子类中被重载。</strong></li>
<li><strong>无法以返回值类型作为重载函数的区分标准。</strong></li>
</ul>
<h2 id="简单地讲："><a href="#简单地讲：" class="headerlink" title="简单地讲："></a>简单地讲：</h2><p>重写：<strong>返回值和参数列表都不能改变！</strong></p>
<p>重载：<strong>参数列表必须改变</strong>！</p>
<p><strong>参数列表相同，返回值不同既不属于重载也不属于重写</strong>！！！</p>
]]></content>
      <categories>
        <category>java学习笔记</category>
      </categories>
      <tags>
        <tag>java_core</tag>
        <tag>java_oop</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat&amp;Servlet基础</title>
    <url>/2021/08/14/JavaWeb/Tomcat&amp;Servlet%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>Servlet、Tomcat基础知识点，仅供参考</p>
<p>19年黑马<code>JavaWeb</code>课程的笔记</p>
<span id="more"></span>

<h2 id="Servlet-Tomcat？"><a href="#Servlet-Tomcat？" class="headerlink" title="Servlet? Tomcat？"></a>Servlet? Tomcat？</h2><p>在讲解<code>Servlet</code>之前，先补充一些<code>web</code>服务器的知识，所谓服务器，通俗上的理解就是安装了服务器软件的计算机。这些服务器软件通过接受用户请求、处理用户请求，回传响应来实现提供某一种服务。</p>
<p>而<code>Tomcat</code>就可以理解为是一种服务器软件。</p>
<p><code>Servlet</code>全名是：<code>server applet</code>，也就是运行在服务端的小程序，这些小程序配合服务器软件处理具体的业务。因此通常服务器接收到具体的请求的时候，服务器会将请求分配给相应的<code>servlet</code>进行处理，再将<code>servlet</code>的响应结果回传给用户。</p>
<p><img src="/2021/08/14/JavaWeb/Tomcat&Servlet%E5%9F%BA%E7%A1%80/image-20210809184109992.png" alt="image-20210809184109992"></p>
<h2 id="Tomcat服务器安装"><a href="#Tomcat服务器安装" class="headerlink" title="Tomcat服务器安装"></a>Tomcat服务器安装</h2><p>下载地址：<a href="http://tomcat.apache.org/">Apache Tomcat® - Welcome!</a></p>
<p>解压压缩包，建议不带中文，可以看到Tomcat服务器的如下目录结构：</p>
<p><img src="/2021/08/14/JavaWeb/Tomcat&Servlet%E5%9F%BA%E7%A1%80/image-20210809184145766.png" alt="image-20210809184145766"></p>
<img src="/2021/08/14/JavaWeb/Tomcat&Servlet%E5%9F%BA%E7%A1%80/tomcat目录结构.png" alt="tomcat目录结构" style="zoom:200%;">

<p>在<code>bin</code>目录下双击<code>startup.bat</code>即可启动<code>tomcat</code></p>
<p><img src="/2021/08/14/JavaWeb/Tomcat&Servlet%E5%9F%BA%E7%A1%80/image-20210809184319851.png" alt="image-20210809184319851"></p>
<h2 id="Tomcat部署配置"><a href="#Tomcat部署配置" class="headerlink" title="Tomcat部署配置"></a>Tomcat部署配置</h2><p><img src="/2021/08/14/JavaWeb/Tomcat&Servlet%E5%9F%BA%E7%A1%80/image-20210809184429573.png" alt="image-20210809184429573"></p>
<h2 id="Servlet配置"><a href="#Servlet配置" class="headerlink" title="Servlet配置"></a>Servlet配置</h2><h3 id="基于XML的配置"><a href="#基于XML的配置" class="headerlink" title="基于XML的配置"></a>基于XML的配置</h3><ol>
<li><p>创建<code>JavaEE</code>项目</p>
</li>
<li><p>定义一个类，实现Servlet接口</p>
</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ServletDemo1 implements Servlet</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>实现接口中的抽象方法</li>
<li>配置Servlet， 在web.xml中配置：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Servlet --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.itcast.web.servlet.ServletDemo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h4><ol>
<li>当服务器接受到客户端浏览器的请求后，会解析请求<code>URL</code>路径，获取访问的<code>Servlet</code>的资源路径</li>
<li>查找<code>web.xml</code>文件，是否有对应的<code>&lt;url-pattern&gt;</code>标签体内容。</li>
<li>如果有，则在找到对应的<code>&lt;servlet-class&gt;</code>全类名</li>
<li><code>tomcat</code>会将字节码文件加载进内存，并且创建其对象</li>
<li>调用其方法</li>
</ol>
<h3 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h3><ol>
<li><p>创建<code>JavaEE</code>项目，选择<code>Servlet</code>的版本<strong>3.0</strong>以上，可以不创建<code>web.xml</code></p>
</li>
<li><p>定义一个类，实现<code>Servlet</code>接口</p>
</li>
<li><p>复写方法</p>
</li>
<li><p>在类上使用<code>@WebServlet</code>注解，进行配置</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebServlet(&quot;资源路径&quot;)</span><br></pre></td></tr></table></figure>

<p>   这个注解的源代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface WebServlet &#123;</span><br><span class="line">	String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt;</span><br><span class="line">	String[] value() default &#123;&#125;;//代表urlPatterns()属性配置</span><br><span class="line">	String[] urlPatterns() default &#123;&#125;;//相当于&lt;url-pattern&gt;</span><br><span class="line">	int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt;</span><br><span class="line">	WebInitParam[] initParams() default &#123;&#125;;</span><br><span class="line">	boolean asyncSupported() default false;</span><br><span class="line">	String smallIcon() default &quot;&quot;;</span><br><span class="line">	String largeIcon() default &quot;&quot;;</span><br><span class="line">	String description() default &quot;&quot;;</span><br><span class="line">	String displayName() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h2><p>一个<code>servlet</code>程序要想在<code>Web</code>服务器上运行，一般需要四个步骤：</p>
<ol>
<li>装入</li>
<li>初始化</li>
<li>提供服务</li>
<li>销毁</li>
</ol>
<p>其中程序员能决定，从步骤2开始，到步骤4，装入一般交给<code>web</code>服务器，准确点来说是服务器软件，如<code>Tomcat</code>负责。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化，也就是实例化<code>Servlet</code>的具体实现类的工作，这个动作会调用<code>Servlet</code>接口的<code>init()</code>，在整个<code>servlet</code>生命周期中只会执行一次。</p>
<p>那这里就产生了两个问题</p>
<h4 id="Servlet什么时候初始化？"><a href="#Servlet什么时候初始化？" class="headerlink" title="Servlet什么时候初始化？"></a>Servlet什么时候初始化？</h4><p>默认情况下，第一次被访问时，Servlet类就被初始化，可以配置执行Servlet的创建时机。</p>
<p>在<code>&lt;servlet&gt;</code>标签下配置</p>
<ol>
<li>第一次被访问时，创建<code>&lt;load-on-startup&gt;</code>的值为负数</li>
<li>在服务器启动时，创建<code>&lt;load-on-startup&gt;</code>的值为0或正整数</li>
</ol>
<h4 id="Servlet是单例的"><a href="#Servlet是单例的" class="headerlink" title="Servlet是单例的"></a>Servlet是单例的</h4><p>Servlet的初始化在整个生命周期过程中只执行一次，这就说明对于每一个<code>Servlet</code>的具体实现类被加载之后，必须要走完整个生命周期，才能再次创建相同实现类的实例，<strong>因此在内存中只存在唯一对象，<code>Servlet</code>是单例的</strong>，<strong>一旦涉及到单例，就可能存在线程安全问题</strong>。</p>
<p><strong>因此尽量不要在<code>Servlet</code>中定义成员变量。</strong>即使定义了成员变量，也不要修改值</p>
<h3 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h3><p>该过程会执行<code>service()</code>，执行多次，每次访问Servlet时，Service方法都会被调用一次。</p>
<p>由于对<code>Servlet</code>接口的进一步封装，现在也很少直接在<code>service()</code>进行编码，一般使用的是<code>HttpServlet</code>的<code>doGet()</code>、<code>doPost()</code>等</p>
<h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>执行destroy方法，只执行一次，<code>Servlet</code>被销毁时执行。服务器关闭时，Servlet被销毁</p>
<ul>
<li>只有服务器正常关闭时，才会执行destroy方法。</li>
<li>destroy方法在<code>Servlet</code>被销毁之前执行，一般用于释放资源</li>
</ul>
<h2 id="Servlet-API"><a href="#Servlet-API" class="headerlink" title="Servlet API"></a>Servlet API</h2><p>![Servlet API类图](Tomcat&amp;Servlet基础/Servlet API类图.png)</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="Servlet实现相关"><a href="#Servlet实现相关" class="headerlink" title="Servlet实现相关"></a>Servlet实现相关</h4><ul>
<li>javax.servlet.Servlet</li>
<li>javax.servlet.GenericServlet</li>
<li>javax.servlet.http.HttpServlet</li>
</ul>
<h4 id="Servlet配置文件相关（Web-xml解析结果）"><a href="#Servlet配置文件相关（Web-xml解析结果）" class="headerlink" title="Servlet配置文件相关（Web.xml解析结果）"></a>Servlet配置文件相关（Web.xml解析结果）</h4><ul>
<li>javax.servlet.ServletConfig</li>
</ul>
<h4 id="响应和请求"><a href="#响应和请求" class="headerlink" title="响应和请求"></a>响应和请求</h4><ul>
<li>javax.servlet.ServletResponse</li>
<li>javax.servlet.ServletRequest</li>
<li>javax.servlet.http.HttpServletResponse</li>
<li>javax.servlet.http.HttpServletRequest</li>
</ul>
<h4 id="会话跟踪"><a href="#会话跟踪" class="headerlink" title="会话跟踪"></a>会话跟踪</h4><ul>
<li>javax.servlet.http.HttpSession</li>
<li>javax.servlet.http.HttpSessionBindingListener</li>
<li>javax.servlet.http.HttpSessionBindingEvent</li>
</ul>
<h4 id="Servlet上下文环境"><a href="#Servlet上下文环境" class="headerlink" title="Servlet上下文环境"></a>Servlet上下文环境</h4><ul>
<li>javax.servlet.ServletContext</li>
</ul>
<h4 id="Servlet协作"><a href="#Servlet协作" class="headerlink" title="Servlet协作"></a>Servlet协作</h4><ul>
<li>javax.servlet.RequestDispatcher</li>
</ul>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><ul>
<li>javax.servlet.http.Cookie</li>
</ul>
<h4 id="Utils"><a href="#Utils" class="headerlink" title="Utils"></a>Utils</h4><ul>
<li>javax.servlet.http.HttpUtils</li>
</ul>
]]></content>
      <categories>
        <category>JavaWeb程序设计</category>
      </categories>
      <tags>
        <tag>javaweb_servlet</tag>
        <tag>javaweb_tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>常用正则表达式</title>
    <url>/2021/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>学习正则表达式：<a href="https://www.argentoaskia.tech/2021/08/13/Java/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#more">java正则表达式</a></p>
<h2 id="常用表达式举例"><a href="#常用表达式举例" class="headerlink" title="常用表达式举例"></a>常用表达式举例</h2><span id="more"></span>

<h3 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h3><h5 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[0-9]*$</span><br></pre></td></tr></table></figure>

<h5 id="n位数字（n为具体数字）"><a href="#n位数字（n为具体数字）" class="headerlink" title="n位数字（n为具体数字）"></a>n位数字（n为具体数字）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^\d&#123;n&#125;$</span><br></pre></td></tr></table></figure>

<h5 id="至少n位的数字"><a href="#至少n位的数字" class="headerlink" title="至少n位的数字"></a>至少n位的数字</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^\d&#123;n,&#125;$</span><br></pre></td></tr></table></figure>

<h5 id="m-n位的数字"><a href="#m-n位的数字" class="headerlink" title="m-n位的数字"></a>m-n位的数字</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^\d&#123;m,n&#125;$</span><br></pre></td></tr></table></figure>

<h5 id="零和非零开头的数字"><a href="#零和非零开头的数字" class="headerlink" title="零和非零开头的数字"></a>零和非零开头的数字</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(0|[1-9][0-9]*)$</span><br></pre></td></tr></table></figure>

<h5 id="非零开头的最多带两位小数的数字"><a href="#非零开头的最多带两位小数的数字" class="headerlink" title="非零开头的最多带两位小数的数字"></a>非零开头的最多带两位小数的数字</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^([1-9][0-9]*)+(\.[0-9]&#123;1,2&#125;)?$</span><br></pre></td></tr></table></figure>

<h5 id="带1-2位小数的正数或负数"><a href="#带1-2位小数的正数或负数" class="headerlink" title="带1-2位小数的正数或负数"></a>带1-2位小数的正数或负数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(\-)?\d+(\.\d&#123;1,2&#125;)$</span><br></pre></td></tr></table></figure>

<h5 id="正数、负数、和小数"><a href="#正数、负数、和小数" class="headerlink" title="正数、负数、和小数"></a>正数、负数、和小数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(\-|\+)?\d+(\.\d+)?$</span><br></pre></td></tr></table></figure>

<h5 id="有两位小数的正实数"><a href="#有两位小数的正实数" class="headerlink" title="有两位小数的正实数"></a>有两位小数的正实数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[0-9]+(\.[0-9]&#123;2&#125;)?$</span><br></pre></td></tr></table></figure>

<h5 id="有1-3位小数的正实数"><a href="#有1-3位小数的正实数" class="headerlink" title="有1~3位小数的正实数"></a>有1~3位小数的正实数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[0-9]+(\.[0-9]&#123;1,3&#125;)?$</span><br></pre></td></tr></table></figure>

<h5 id="非零的正整数"><a href="#非零的正整数" class="headerlink" title="非零的正整数"></a>非零的正整数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[1-9]\d*$</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^([1-9][0-9]*)&#123;1,3&#125;$</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^\+?[1-9][0-9]*$</span><br></pre></td></tr></table></figure>

<h5 id="非零的负整数"><a href="#非零的负整数" class="headerlink" title="非零的负整数"></a>非零的负整数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^\-[1-9][]0-9&quot;*$</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^-[1-9]\d*$</span><br></pre></td></tr></table></figure>

<h5 id="非负整数"><a href="#非负整数" class="headerlink" title="非负整数"></a>非负整数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^\d+$</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[1-9]\d*|0$</span><br></pre></td></tr></table></figure>

<h5 id="非正整数"><a href="#非正整数" class="headerlink" title="非正整数"></a>非正整数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^-[1-9]\d*|0$</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^((-\d+)|(0+))$</span><br></pre></td></tr></table></figure>

<h5 id="非负浮点数"><a href="#非负浮点数" class="headerlink" title="非负浮点数"></a>非负浮点数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^\d+(\.\d+)?$</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</span><br></pre></td></tr></table></figure>

<h5 id="非正浮点数"><a href="#非正浮点数" class="headerlink" title="非正浮点数"></a>非正浮点数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^((-\d+(\.\d+)?)|(0+(\.0+)?))$</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</span><br></pre></td></tr></table></figure>

<h5 id="正浮点数"><a href="#正浮点数" class="headerlink" title="正浮点数"></a>正浮点数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</span><br></pre></td></tr></table></figure>

<h5 id="负浮点数"><a href="#负浮点数" class="headerlink" title="负浮点数"></a>负浮点数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</span><br></pre></td></tr></table></figure>

<h5 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(-?\d+)(\.\d+)?$</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</span><br></pre></td></tr></table></figure>

<h3 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h3><h5 id="汉字"><a href="#汉字" class="headerlink" title="汉字"></a>汉字</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[\u4e00-\u9fa5]&#123;0,&#125;$</span><br></pre></td></tr></table></figure>

<h5 id="英文和数字"><a href="#英文和数字" class="headerlink" title="英文和数字"></a>英文和数字</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[A-Za-z0-9]+$</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[A-Za-z0-9]&#123;4,40&#125;$</span><br></pre></td></tr></table></figure>

<h5 id="长度为3-20的所有字符"><a href="#长度为3-20的所有字符" class="headerlink" title="长度为3-20的所有字符"></a>长度为3-20的所有字符</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^.&#123;3,20&#125;$</span><br></pre></td></tr></table></figure>

<h5 id="由26个英文字母组成的字符串"><a href="#由26个英文字母组成的字符串" class="headerlink" title="由26个英文字母组成的字符串"></a>由26个英文字母组成的字符串</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[A-Za-z]+$</span><br></pre></td></tr></table></figure>

<h5 id="由26个大写英文字母组成的字符串"><a href="#由26个大写英文字母组成的字符串" class="headerlink" title="由26个大写英文字母组成的字符串"></a>由26个大写英文字母组成的字符串</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[A-Z]+$</span><br></pre></td></tr></table></figure>

<h5 id="由26个小写英文字母组成的字符串"><a href="#由26个小写英文字母组成的字符串" class="headerlink" title="由26个小写英文字母组成的字符串"></a>由26个小写英文字母组成的字符串</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[a-z]+$</span><br></pre></td></tr></table></figure>

<h5 id="由数字和26个英文字母组成的字符串"><a href="#由数字和26个英文字母组成的字符串" class="headerlink" title="由数字和26个英文字母组成的字符串"></a>由数字和26个英文字母组成的字符串</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[A-Za-z0-9]+$</span><br></pre></td></tr></table></figure>

<h5 id="由数字、26个英文字母或者下划线组成的字符串"><a href="#由数字、26个英文字母或者下划线组成的字符串" class="headerlink" title="由数字、26个英文字母或者下划线组成的字符串"></a>由数字、26个英文字母或者下划线组成的字符串</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^\w+$ 或 ^\w&#123;3,20&#125;$</span><br></pre></td></tr></table></figure>

<h5 id="中文、英文、数字包括下划线"><a href="#中文、英文、数字包括下划线" class="headerlink" title="中文、英文、数字包括下划线"></a>中文、英文、数字包括下划线</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[\u4E00-\u9FA5A-Za-z0-9_]+$</span><br></pre></td></tr></table></figure>

<h5 id="中文、英文、数字但不包括下划线等符号"><a href="#中文、英文、数字但不包括下划线等符号" class="headerlink" title="中文、英文、数字但不包括下划线等符号"></a>中文、英文、数字但不包括下划线等符号</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[\u4E00-\u9FA5A-Za-z0-9]+$</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$</span><br></pre></td></tr></table></figure>

<h5 id="可以输入含有-amp-’-quot-等字符"><a href="#可以输入含有-amp-’-quot-等字符" class="headerlink" title="可以输入含有^%&amp;’,;=?$&quot;等字符"></a>可以输入含有^%&amp;’,;=?$&quot;等字符</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[^%&amp;&#x27;,;=?$\x22]+</span><br></pre></td></tr></table></figure>

<h5 id="禁止输入含有-的字符"><a href="#禁止输入含有-的字符" class="headerlink" title="禁止输入含有~的字符"></a>禁止输入含有~的字符</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[^~\x22]+</span><br></pre></td></tr></table></figure>

<h3 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h3><h5 id="Email地址"><a href="#Email地址" class="headerlink" title="Email地址"></a>Email地址</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br></pre></td></tr></table></figure>

<h5 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(\.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+\.?</span><br></pre></td></tr></table></figure>

<h5 id="InternetURL"><a href="#InternetURL" class="headerlink" title="InternetURL"></a>InternetURL</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a-zA-z]+://[^\s]*</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</span><br></pre></td></tr></table></figure>

<h5 id="手机号码"><a href="#手机号码" class="headerlink" title="手机号码"></a>手机号码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(13[0-9]|14[5|7]|15[0|1|2|3|4|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$</span><br></pre></td></tr></table></figure>

<h5 id="电话号码-“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX"><a href="#电话号码-“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX" class="headerlink" title="电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)"></a>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</span><br></pre></td></tr></table></figure>

<h5 id="国内电话号码-0511-4405222、021-87888822"><a href="#国内电话号码-0511-4405222、021-87888822" class="headerlink" title="国内电话号码(0511-4405222、021-87888822)"></a>国内电话号码(0511-4405222、021-87888822)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</span><br></pre></td></tr></table></figure>

<h5 id="电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）"><a href="#电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）" class="headerlink" title="电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）"></a>电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((\d&#123;11&#125;)|^((\d&#123;7,8&#125;)|(\d&#123;4&#125;|\d&#123;3&#125;)-(\d&#123;7,8&#125;)|(\d&#123;4&#125;|\d&#123;3&#125;)-(\d&#123;7,8&#125;)-(\d&#123;4&#125;|\d&#123;3&#125;|\d&#123;2&#125;|\d&#123;1&#125;)|(\d&#123;7,8&#125;)-(\d&#123;4&#125;|\d&#123;3&#125;|\d&#123;2&#125;|\d&#123;1&#125;))$)</span><br></pre></td></tr></table></figure>

<h5 id="身份证号-15位、18位数字-，最后一位是校验位，可能为数字或字符X"><a href="#身份证号-15位、18位数字-，最后一位是校验位，可能为数字或字符X" class="headerlink" title="身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X"></a>身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)</span><br></pre></td></tr></table></figure>

<h5 id="帐号是否合法-字母开头，允许5-16字节，允许字母数字下划线"><a href="#帐号是否合法-字母开头，允许5-16字节，允许字母数字下划线" class="headerlink" title="帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)"></a>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</span><br></pre></td></tr></table></figure>

<h5 id="密码-以字母开头，长度在6-18之间，只能包含字母、数字和下划线"><a href="#密码-以字母开头，长度在6-18之间，只能包含字母、数字和下划线" class="headerlink" title="密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)"></a>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[a-zA-Z]\w&#123;5,17&#125;$</span><br></pre></td></tr></table></figure>

<h5 id="强密码-必须包含大小写字母和数字的组合，不能使用特殊字符，长度在-8-10-之间"><a href="#强密码-必须包含大小写字母和数字的组合，不能使用特殊字符，长度在-8-10-之间" class="headerlink" title="强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)"></a>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]&#123;8,10&#125;$</span><br></pre></td></tr></table></figure>

<h5 id="强密码-必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间"><a href="#强密码-必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间" class="headerlink" title="强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)"></a>强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$</span><br></pre></td></tr></table></figure>

<h5 id="日期格式"><a href="#日期格式" class="headerlink" title="日期格式"></a>日期格式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</span><br></pre></td></tr></table></figure>

<h5 id="一年的12个月-01～09和1～12"><a href="#一年的12个月-01～09和1～12" class="headerlink" title="一年的12个月(01～09和1～12)"></a>一年的12个月(01～09和1～12)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(0?[1-9]|1[0-2])$</span><br></pre></td></tr></table></figure>

<h5 id="一个月的31天-01～09和1～31"><a href="#一个月的31天-01～09和1～31" class="headerlink" title="一个月的31天(01～09和1～31)"></a>一个月的31天(01～09和1～31)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^((0?[1-9])|((1|2)[0-9])|30|31)$</span><br></pre></td></tr></table></figure>

<h5 id="xml文件"><a href="#xml文件" class="headerlink" title="xml文件"></a>xml文件</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</span><br></pre></td></tr></table></figure>

<h5 id="中国邮政编码"><a href="#中国邮政编码" class="headerlink" title="中国邮政编码"></a>中国邮政编码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1-9]\d&#123;5&#125;(?!\d) </span><br></pre></td></tr></table></figure>

<h5 id="腾讯QQ号"><a href="#腾讯QQ号" class="headerlink" title="腾讯QQ号"></a>腾讯QQ号</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1-9][0-9]&#123;4,&#125;</span><br></pre></td></tr></table></figure>

<h5 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;)(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;))&#123;3&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符过滤类"><a href="#字符过滤类" class="headerlink" title="字符过滤类"></a>字符过滤类</h3><h5 id="中文字符的正则表达式"><a href="#中文字符的正则表达式" class="headerlink" title="中文字符的正则表达式"></a>中文字符的正则表达式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[\u4e00-\u9fa5]</span><br></pre></td></tr></table></figure>

<h5 id="双字节字符"><a href="#双字节字符" class="headerlink" title="双字节字符"></a>双字节字符</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[^\x00-\xff] </span><br></pre></td></tr></table></figure>

<p>(包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</p>
<h5 id="空白行的正则表达式"><a href="#空白行的正则表达式" class="headerlink" title="空白行的正则表达式"></a>空白行的正则表达式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\n\s*\r</span><br></pre></td></tr></table></figure>

<p>(可以用来删除空白行)</p>
<h5 id="HTML标记的正则表达式"><a href="#HTML标记的正则表达式" class="headerlink" title="HTML标记的正则表达式"></a>HTML标记的正则表达式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;(\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt;</span><br></pre></td></tr></table></figure>

<p> <strong>( 首尾空白字符的正则表达式：<code>^\s\*|\s\*$</code>或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</strong></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>匹配字符中不出现某些特殊字符可以这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[^\&lt;,\&gt;,\/,\\,\|,\:,\&quot;,\*,\?]		// 不匹配带有\/*:?&quot;&lt;&gt;|的字符串</span><br></pre></td></tr></table></figure>

<p>匹配目录是否合法(windows)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[C-Z]:\\([^\&lt;,\&gt;,\/,\\,\|,\:,\&quot;,\*,\?]+\\)*$</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>常用正则表达式持续更新</tag>
      </tags>
  </entry>
  <entry>
    <title>“El表达式”</title>
    <url>/2021/08/31/JavaWeb/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<span id="more"></span>

]]></content>
  </entry>
  <entry>
    <title>hexo恢复搭建</title>
    <url>/2020/02/19/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>写下这篇博客，主要用于记录自己搭建博客过程，以后重装系统后有一个参考的恢复方向（已经干掉重新来了好几次，每次都要找资料，猝），而且，不得不说，windows系统，C盘没100G真的用不了多久，不知道是不是只有我是这样！！😭😭😭😭</p>
<span id="more"></span>

<h2 id="2-提前准备"><a href="#2-提前准备" class="headerlink" title="2.提前准备"></a>2.提前准备</h2><p>安装 <code>Hexo</code> 相当简单，只需要先安装下列应用程序即可：</p>
<ul>
<li><a href="http://nodejs.cn/download/">Node.js</a></li>
<li><a href="https://gitforwindows.org/">Git for Windows</a></li>
<li><a href="https://npm.taobao.org/mirrors/git-for-windows/">Git淘宝源</a></li>
</ul>
<p>可以点击上面的链接进去官网下载，git下载慢的可以去淘宝源。这里我分享我目前用的版本：</p>
<ul>
<li><a href="http://xz.w10a.com/Small/Nodejs.zip">node.js 12.14</a></li>
<li><a href="https://cdn.npm.taobao.org/dist/git-for-windows/v2.29.2.windows.3/Git-2.29.2.3-64-bit.exe">Git-2.29.2.3</a></li>
</ul>
<p>安装过程不再详细说明，简单的全选下一步就行，安装的位置自己喜欢放哪里就放哪里呗（doge）</p>
<h2 id="3-安装npm（cnpm）"><a href="#3-安装npm（cnpm）" class="headerlink" title="3.安装npm（cnpm）"></a>3.安装npm（cnpm）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Win+R)运行 ---&gt; cmd </span><br></pre></td></tr></table></figure>

<p>查看版本：</p>
<pre><code>node -v
npm -v
</code></pre>
<p>因为国内的比较慢，所以安装淘宝源cnpm：</p>
<pre><code>npm install -g cnpm --registry=http://registry.npm.taobao.org
</code></pre>
<p>若发现淘宝源下载过程中出现卡死，则最好换回原服务器：</p>
<pre><code>npm config delete registry
</code></pre>
<h2 id="4-安装hexo"><a href="#4-安装hexo" class="headerlink" title="4.安装hexo"></a>4.安装hexo</h2><p>同样在cmd中安装：</p>
<pre><code>cnpm install -g hexo-cli
</code></pre>
<h2 id="5-初始化hexo"><a href="#5-初始化hexo" class="headerlink" title="5.初始化hexo"></a>5.初始化hexo</h2><ol>
<li><p>选择一个目录，用于本地部署</p>
</li>
<li><p>在目录里边用<code>Git bash</code>或者<code>Powershell</code>，初始化<code>hexo</code></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意：如果你的<code>git</code>版本比较高，如笔者使用的<code>Git-2.31.1-64-bit</code>默认会开启服务器的SSL证书第三方机构签署认证，而<code>github</code>没有，所以可能会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class="line">fatal: unable to access </span><br><span class="line">&#x27;https://github.com/hexojs/hexo-starter.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure>

<p>解决方法是把SSL认证关掉：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure>

<p>或者如果打开了多个bash，把不用的关掉</p>
<p>初始化完成之后使用<code>hexo g</code>、再<code>hexo s</code>，如果弹出默认主题初始页，则说明本地初始化成功了！</p>
<p><img src="/2020/02/19/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA%5Cimage-20210402190136280.png" alt="image-20210402190136280"></p>
<h2 id="6-部署到远端"><a href="#6-部署到远端" class="headerlink" title="6.部署到远端"></a>6.部署到远端</h2><h3 id="6-1创建SSH密钥"><a href="#6-1创建SSH密钥" class="headerlink" title="6.1创建SSH密钥"></a>6.1创建SSH密钥</h3><p>打开<code>gitbash</code>，配置本机用户名和邮箱，生成SSH密钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/19/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA%5Cimage-20210402191410819.png" alt="image-20210402191410819"></p>
<p><strong>生成密钥过程所有的提问全部回车就行</strong></p>
<p>生成的密钥文件放在：<code>C:\Users\（你计算机的当前用户名）\.ssh</code>中</p>
<p><img src="/2020/02/19/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA%5Cimage-20210402201820428.png" alt="image-20210402201820428"></p>
<p><strong>其中pub结尾的为公钥，用记事本打开复制里面的所有内容</strong></p>
<h3 id="6-2将密钥放在远端"><a href="#6-2将密钥放在远端" class="headerlink" title="6.2将密钥放在远端"></a>6.2将密钥放在远端</h3><p>注册Github或者Gitee账号，将复制的公钥添加进SSH中</p>
<p>Setting –&gt; SSh</p>
<p><img src="/2020/02/19/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA%5Cimage-20210402214646615.png" alt="image-20210402214646615"></p>
<h3 id="6-3创建仓库"><a href="#6-3创建仓库" class="headerlink" title="6.3创建仓库"></a>6.3创建仓库</h3><p><img src="/2020/02/19/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA%5Cimage-20210402192650539.png" alt="image-20210402192650539"></p>
<p>同时勾上这个</p>
<p><img src="/2020/02/19/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA%5Cimage-20210402192738568.png" alt="image-20210402192738568"></p>
<h3 id="6-4-配置-comfig-yml"><a href="#6-4-配置-comfig-yml" class="headerlink" title="6.4 配置_comfig.yml"></a>6.4 配置<code>_comfig.yml</code></h3><p>仓库创建好之后，复制仓库地址建议使用SSH（github、gitee都一样的操作）</p>
<p><img src="/2020/02/19/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA%5Cimage-20210402193005129.png" alt="image-20210402193005129"></p>
<p>打开<code>hexo</code>主目录下的<code>_comfig.yml</code>，在最后，修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">  repo: 你刚刚复制的仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>如果你打开文件只看到<code>type</code>，没有<code>repo</code>和<code>branch</code>，自己加上就行了，<strong>注意属性名和属性值之间的空格</strong>，如<code>type</code>和<code>&#39;git&#39;</code>中间是有空格的，<strong>另外type属性的两个单引号，不要去掉！！</strong></p>
<h2 id="7-安装hexo-deployer推进远端"><a href="#7-安装hexo-deployer推进远端" class="headerlink" title="7.安装hexo deployer推进远端"></a>7.安装<code>hexo deployer</code>推进远端</h2><p>回到<code>git bash</code>或者<code>powershell</code>，安装<code>hexo deployer</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>然后推到远端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>这一步Github可能会弹出对话框确认OpenSSH</p>
<p><img src="/2020/02/19/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA%5Cimage-20210402215905251.png" alt="image-20210402215905251"></p>
<p>甚至是提示登陆的窗口：</p>
<p><img src="/2020/02/19/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA/image-20210811150819631.png" alt="image-20210811150819631"></p>
<p>注意：</p>
<p>如果遇到这种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/ArgentoAskia2/ArgentoAskia2.github.io.git/&#x27;: Could not resolve host: github.com</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: RPC failed; curl 56 OpenSSL SSL_read: Connection was reset, errno 10054</span><br><span class="line">send-pack: unexpected disconnect while reading sideband packet</span><br></pre></td></tr></table></figure>

<p>造成上面的情况有很多原因，如果是<code>github</code>，最常见就是<code>github</code>抽风了，访问不了，尝试多几次<code>hexo</code>三连就好。</p>
<p>如果还不行的话，请运行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy </span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>

<p>在进行<code>hexo d</code></p>
<h2 id="8-最后的一步"><a href="#8-最后的一步" class="headerlink" title="8.最后的一步"></a>8.最后的一步</h2><p>对于Github的朋友，你们的小窝估计已经搭好了，访问地址一般都是<strong>用户名.github.io</strong></p>
<p>而对于Gitee的朋友，你们还需要部署GiteePage</p>
<p><img src="/2020/02/19/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA%5Cimage-20210402201359207.png" alt="image-20210402201359207"></p>
<p><img src="/2020/02/19/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA%5Cimage-20210402201430087.png" alt="image-20210402201430087"></p>
<p><img src="/2020/02/19/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA/hexo%E6%81%A2%E5%A4%8D%E6%90%AD%E5%BB%BA%5Cimage-20210402201510671.png" alt="image-20210402201510671"></p>
<p>开启服务之后，这个就是你的博客地址啦，可以通过这个来访问！</p>
]]></content>
      <categories>
        <category>博客运维</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>recovery</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客绑定个人域名</title>
    <url>/2020/12/18/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<h2 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h2><ul>
<li>默认博客已经建好！</li>
<li>默认当事人已经购买了域名，且已经实名认证。（阿里云的、百度的…都可以）</li>
</ul>
<p>当然没有购买域名的同学，请往这里走：<a href="https://promotion.aliyun.com/ntms/act/domainbrand.html?spm=5176.8006371.772226.domainbackorder.b46f7e63AuIXBy">阿里云域名注册</a></p>
<p>在注册域名时，还需要通过一个真实邮箱认证模板，因此需要一个可用的邮箱！</p>
<p>阿里云的实名认证还是很快的，说是两三个工作日内审核，但是我半个小时不到就通过了。</p>
<span id="more"></span>

<h2 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h2><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>先进入<a href="https://dc.console.aliyun.com/next/index?spm=5176.8006371.J_8058803260.1314.54897e63e7caJc#/domain/list/all-domain">阿里云域名后台</a>，点击<img src="/2020/12/18/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D/%E7%82%B9%E5%87%BB%E8%A7%A3%E6%9E%90.png" alt="点击解析"></p>
<p>按下快捷键<code>win+R</code>打开运行，运行<code>cmd</code>，ping您建好的博客地址（若部署在github上的博客则地址就是<code>yourname.github.io</code>,实际上也是一个域名），笔者的hexo博客部署在github上，因此需要这样做：</p>
<p>![ping github](hexo博客绑定个人域名/ping github.png)</p>
<p>在域名解析设置添加两条记录：</p>
<ul>
<li>CNAME记录：设置您的github访问页</li>
<li>A记录：刚刚ping的IP</li>
</ul>
<p>可以参考下笔者的设置</p>
<p><img src="/2020/12/18/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D/%E8%AE%BE%E7%BD%AE.png" alt="设置"></p>
<p>关于这些记录可以参考</p>
<p><img src="/2020/12/18/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D/hexo%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%5CA%E3%80%81cname.png" alt="A、cname"></p>
<p>域名前缀可以参考：</p>
<p><img src="/2020/12/18/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D/hexo%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%5C%E4%B8%BB%E6%9C%BA%E8%AE%B0%E5%BD%95.png" alt="主机记录"></p>
<p>就看你想要<code>www</code>、<code>@</code>还是其他了！</p>
<h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><p>在<code>hexo根目录/source</code>文件夹中添加一个<code>CNAME</code>文件，注意文件无后缀，内容设置为您自己的域名：</p>
<p><img src="/2020/12/18/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D/CNAME.png" alt="CNAME"></p>
<p>保存之后。hexo三连即可！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h2 id="大功告成！"><a href="#大功告成！" class="headerlink" title="大功告成！"></a>大功告成！</h2><p>可以使用域名访问自己的博客啦！</p>
]]></content>
      <categories>
        <category>博客运维</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>recovery</tag>
        <tag>domain</tag>
      </tags>
  </entry>
  <entry>
    <title>关于hexoGenerate</title>
    <url>/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E5%85%B3%E4%BA%8EhexoGenerate/</url>
    <content><![CDATA[<p>本次讲解<code>hexo</code>博客常用的命令：<code>hexo g</code></p>
<span id="more"></span>

<h2 id="如何生成静态文件"><a href="#如何生成静态文件" class="headerlink" title="如何生成静态文件"></a>如何生成静态文件</h2><p>hexo生成静态文件的方法非常简单,只需要使用<code>hexo g</code>命令（当然也可以使用全名<code>hexo generate</code>），你在我的一些关于hexo的文章中可能会看到一个叫素质三连的词，这个词代表你要执行三条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean			// 清空上一次的生成</span><br><span class="line">hexo generate		// 重新生成</span><br><span class="line">hexo server			// 本地启动浏览效果</span><br></pre></td></tr></table></figure>

<p>当然上面的命令在面对文件被改变的时候，可能需要你重新生成，如果不想每次都三连的话，可以使用：<code>hexo generate --watch</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean			</span><br><span class="line">hexo generate --watch		</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>这样，hexo可以监视文件更改并立即重新生成文件。hexo将比较文件的sha1校验和，仅在检测到文件更改时才写入。</p>
<p>如果想生成之后立刻部署到远端，可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate --deploy</span><br></pre></td></tr></table></figure>

<h2 id="生成细节"><a href="#生成细节" class="headerlink" title="生成细节"></a>生成细节</h2><h3 id="public文件夹及URL定位"><a href="#public文件夹及URL定位" class="headerlink" title="public文件夹及URL定位"></a>public文件夹及URL定位</h3><p>你可能会注意到，在你的<strong>博客根目录</strong>中有一个public文件夹，<strong>用于装载生成之后的文件</strong>，也就是说当运行<code>hexo g</code>之后，hexo会将资源经过处理（具体怎样处理待会会讲）放在这个文件夹里面，当你运行<code>hexo server</code>的时候，本地启动的URL也是根据这个文件来设定的。</p>
<p>比如，当你素质三连之后，你打开<code>http://localhost:4000/</code>，那么这个地址定位到的相应html文件就是你public文件夹下的index.html（URL中的index.html可以不写，默认就是定位这个文件）。没错，你可能猜到了，如果你想访问某个页面，只需要定位它的html资源在public文件夹的哪个地方就可以，比如我想访问关于页面（这个页面的位置是public/about/index.html）,那么我就可以修改URl为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:4000/about/</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E5%85%B3%E4%BA%8EhexoGenerate/image-20210404005943351-16287272629311.png" alt="image-20210404005943351"></p>
<p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E5%85%B3%E4%BA%8EhexoGenerate/image-20210404010237512.png" alt="image-20210404010237512"></p>
<p>对于远端来讲也是差不多的，<code>hexo deploy</code>指令只是将public文件夹里的所有·内容上传到远端，那么这个时候只要把<code>http://localhost:4000/</code>替换成<code>远端服务器的地址</code>就行！</p>
<h3 id="生成哪些内容"><a href="#生成哪些内容" class="headerlink" title="生成哪些内容"></a>生成哪些内容</h3><p><code>hexo g</code>之后，<code>hexo</code>会把这些内容放在public文件夹中，包括单不仅限于：你的文章、你自定义的特效（鼠标点击特效等）、你的文章设置（文章加密）、头像和背景图等媒体、归档、分类、标签等。涉及到的目录包括<code>source</code>、<code>themes</code>目录下的<code>source</code>、<code>script</code>、<code>layout</code>等，其中重要的是<code>source</code>文件夹，因为该文件夹的内容都会被放在public中</p>
<p>另外，hexo对<code>source</code>中的<code>_post</code>文件夹内的所有文章的生成，不直接用部署文件名二而是采用<code>年/月/日/文章标题/index.html</code>的方式来部署（当然可以在<code>_config.yml</code>中修改这个生成方式），如果你的文章位于<code>_post\XXX\</code>目录下面，那么生成的就是<code>年/月/日/XXX/文章标题/index.html</code>，多级目录以此类推！如下图：</p>
<p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E5%85%B3%E4%BA%8EhexoGenerate/image-20210404014541573.png" alt="image-20210404014541573"></p>
<p>那么<code>hexo g</code>之后public对应的访问路径就是：</p>
<p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E5%85%B3%E4%BA%8EhexoGenerate/image-20210404014800864.png" alt="image-20210404014800864"></p>
<h3 id="添油加醋"><a href="#添油加醋" class="headerlink" title="添油加醋"></a>添油加醋</h3><p>现在知道了<code>source</code>文件夹的东西都会被放在public中，也知道在本地启动之后可以通过手写URL的方式来访问，但是还有一个问题：我们在<code>source</code>文件夹中写的是<code>markdown</code>，而public中确实html文件，这说明了<code>hexo g</code>并不是简单的把文章复制，而是对文章进行过加工，仔细对比public中的hello-world和source中的hello-world可知：hexo会对所有的文章进行主题格式化，也就是说会把主题需要的CSS样式、JS等都添加进去文章中：</p>
<p>这里是文章的地方：</p>
<p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E5%85%B3%E4%BA%8EhexoGenerate/image-20210404020004962.png" alt="image-20210404020004962"></p>
<p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E5%85%B3%E4%BA%8EhexoGenerate/image-20210404020040346.png" alt="image-20210404020040346"></p>
<p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E5%85%B3%E4%BA%8EhexoGenerate/image-20210404020139825.png" alt="image-20210404020139825"></p>
<p>然而其他代码呢？其他代码与主题有关，通常是主题的JS、CSS具体可以参考自己主题里面的<code>source</code>文件夹</p>
<h2 id="自定义页面"><a href="#自定义页面" class="headerlink" title="自定义页面"></a>自定义页面</h2><h3 id="markdown-内嵌HTML、JS、CSS"><a href="#markdown-内嵌HTML、JS、CSS" class="headerlink" title="markdown 内嵌HTML、JS、CSS"></a>markdown 内嵌HTML、JS、CSS</h3><h3 id="使用自定义HTML页面"><a href="#使用自定义HTML页面" class="headerlink" title="使用自定义HTML页面"></a>使用自定义HTML页面</h3><p>既然我们知道了他的生成方式和定位方式，那我们就可以将html、放一些资源进去了吗？理论上可行，因为知道hexo对于资源是会添油加醋的，所以需要配合好主题自带的样式和JS，当然可以通过不指定hexo渲染方法来实现，具体方法:</p>
<h4 id="1-在source文件夹中新建一个文件夹-名字随意-用于装载不经过主题格式化的HTML。"><a href="#1-在source文件夹中新建一个文件夹-名字随意-用于装载不经过主题格式化的HTML。" class="headerlink" title="1.在source文件夹中新建一个文件夹(名字随意),用于装载不经过主题格式化的HTML。"></a>1.在source文件夹中新建一个文件夹(名字随意),用于装载不经过主题格式化的HTML。</h4><p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E5%85%B3%E4%BA%8EhexoGenerate/image-20210406114751633.png" alt="image-20210406114751633"></p>
<h4 id="2-配置根目录的-comfig-yml，指定跳过渲染位置"><a href="#2-配置根目录的-comfig-yml，指定跳过渲染位置" class="headerlink" title="2.配置根目录的_comfig.yml，指定跳过渲染位置"></a>2.配置根目录的_comfig.yml，指定跳过渲染位置</h4><p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E5%85%B3%E4%BA%8EhexoGenerate/image-20210406114914766.png" alt="image-20210406114914766"></p>
<p>注意配置格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skip_render:</span><br><span class="line">	- &quot;目录名/*&quot;			// 目录下的所有文件都跳过渲染</span><br><span class="line">	- &quot;目录名/**&quot;			// 目录下的所有文件、所有文件夹都跳过渲染</span><br><span class="line">	- &quot;目录1/目录2/*&quot;	   // 目录2下面的所有文件都跳过渲染</span><br></pre></td></tr></table></figure>

<h4 id="3-添加主题模板"><a href="#3-添加主题模板" class="headerlink" title="3.添加主题模板"></a>3.添加主题模板</h4><p>在上面已经将结果，当我们使用<code>hexo g</code>的时候，hexo会根据主题的不同给我们的文章添加一些JS、CSS来渲染文章，第二部我们禁止了这种渲染，所以就需要手动把这些JS、CSS加上，这些文件一般在<code>themes/(主题名称)/source</code>里面，把这些文件复制到你新建的文件夹那里（笔者的是<code>norender</code>）</p>
<h3 id="使用自定义的404错误页"><a href="#使用自定义的404错误页" class="headerlink" title="使用自定义的404错误页"></a>使用自定义的404错误页</h3><p>不需要<code>hexo-generator-index</code>插件渲染文章，不指定主题模板</p>
<h3 id="实例：使用自定义时钟"><a href="#实例：使用自定义时钟" class="headerlink" title="实例：使用自定义时钟"></a>实例：使用自定义时钟</h3><h3 id="生成无渲染模板"><a href="#生成无渲染模板" class="headerlink" title="生成无渲染模板"></a>生成无渲染模板</h3>]]></content>
      <categories>
        <category>博客运维</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>explain</tag>
        <tag>reference</tag>
      </tags>
  </entry>
  <entry>
    <title>添加搜索功能</title>
    <url>/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="基于next-hexo-generator-searchdb的搜索功能"><a href="#基于next-hexo-generator-searchdb的搜索功能" class="headerlink" title="基于next + hexo-generator-searchdb的搜索功能"></a>基于next + hexo-generator-searchdb的搜索功能</h2><span id="more"></span>

<h2 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h2><p>在博客根目录下，启动git bash，键入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>如果添加了淘宝源，键入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<h2 id="修改博客和主题的-config-yml"><a href="#修改博客和主题的-config-yml" class="headerlink" title="修改博客和主题的__config.yml"></a>修改博客和主题的__config.yml</h2><h3 id="博客的-config-yml"><a href="#博客的-config-yml" class="headerlink" title="博客的__config.yml"></a>博客的__config.yml</h3><p>在配置文件末尾添加：</p>
<p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/image-20210812101118677.png" alt="image-20210812101118677"></p>
<p>其中这些参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">path：表示搜索后生成的文件路径，可以生成xml和json两种格式；将path设置为“content.json”就可以替代第二个插件。</span><br><span class="line">field：表示搜索的范围，有“post、page和all”三种值。</span><br><span class="line">    post：所有的文章；</span><br><span class="line">    page：所有顶部导航选项的页面；</span><br><span class="line">    all：所有的文章和顶部导航选项的页面。</span><br><span class="line">content：是否包含搜索到的文章的全部内容。如果false，生成的结果只包括标题和创建时间这些信息，没有文章主体。默认情况下是true.</span><br><span class="line">format：搜索到的内容、选项的格式。</span><br><span class="line">    html(默认)：将html原文本缩略。</span><br><span class="line">    striptags：将html原文本缩略，并删除所有标记。</span><br><span class="line">    raw：记下每一篇文章或每一页的文字。</span><br></pre></td></tr></table></figure>

<h3 id="主题的-config-yml"><a href="#主题的-config-yml" class="headerlink" title="主题的__config.yml"></a>主题的__config.yml</h3><p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/image-20210812101256981.png" alt="image-20210812101256981"></p>
<p>当然<code>enable</code>后面的东西可以自行修改。</p>
<h2 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h2><p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/image-20210812104330740.png" alt="image-20210812104330740"></p>
]]></content>
      <categories>
        <category>博客运维</category>
      </categories>
      <tags>
        <tag>hexo_优化</tag>
        <tag>hexo_添加</tag>
      </tags>
  </entry>
  <entry>
    <title>添加评论功能</title>
    <url>/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="基于next-来必力添加评论功能"><a href="#基于next-来必力添加评论功能" class="headerlink" title="基于next+来必力添加评论功能"></a>基于next+来必力添加评论功能</h2><span id="more"></span>

<h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p><a href="https://livere.com/">来必力官网</a></p>
<p>貌似需要科学上网，但是我在宿舍自己电脑能直接上，换成机房的电脑就不行😥😥</p>
<h2 id="复制UID"><a href="#复制UID" class="headerlink" title="复制UID"></a>复制UID</h2><p>进入管理界面，点击代码管理，复制<code>data-uid</code>后面的<code>uid</code></p>
<p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/image-20210812085250263.png" alt="image-20210812085250263"></p>
<h2 id="配置-Config-yml"><a href="#配置-Config-yml" class="headerlink" title="配置_Config.yml"></a>配置_Config.yml</h2><p>配置位置位于：</p>
<p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/image-20210812085408153.png" alt="image-20210812085408153"></p>
<p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/image-20210812085535585.png" alt="image-20210812085535585"></p>
<h2 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h2><p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/image-20210812090325909.png" alt="image-20210812090325909"></p>
]]></content>
      <categories>
        <category>博客运维</category>
      </categories>
      <tags>
        <tag>hexo_优化</tag>
        <tag>hexo_添加</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo模板修改和使用</title>
    <url>/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E6%A8%A1%E6%9D%BF%E4%BF%AE%E6%94%B9%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>一些常用的模板和草稿、<code>font-master</code>知识都会放在这里</p>
<span id="more"></span>

<p><code>hexo</code>的模板一般放在：</p>
<p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E6%A8%A1%E6%9D%BF%E4%BF%AE%E6%94%B9%E5%92%8C%E4%BD%BF%E7%94%A8/image-20210811172544700.png" alt="image-20210811172544700"></p>
<p>有三个文件</p>
<p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E6%A8%A1%E6%9D%BF%E4%BF%AE%E6%94%B9%E5%92%8C%E4%BD%BF%E7%94%A8/image-20210811173809300.png" alt="image-20210811173809300"></p>
<p>对应new命令的三种创建类型！</p>
<p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/hexo%E6%A8%A1%E6%9D%BF%E4%BF%AE%E6%94%B9%E5%92%8C%E4%BD%BF%E7%94%A8/image-20210811172759610.png" alt="image-20210811172759610"></p>
<p>模板涉及到一些<code>Font-matter</code>还有一些简单的模板设置都会在这里一一介绍</p>
<h2 id="Font-matter"><a href="#Font-matter" class="headerlink" title="Font-matter"></a>Font-matter</h2><h2 id="一些模板"><a href="#一些模板" class="headerlink" title="一些模板"></a>一些模板</h2><h3 id="Post模板一："><a href="#Post模板一：" class="headerlink" title="Post模板一："></a>Post模板一：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">layout: true</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客运维</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>reference</tag>
        <tag>features</tag>
      </tags>
  </entry>
  <entry>
    <title>解决hexo部署到github上图片无法显示问题</title>
    <url>/2021/08/11/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E8%A7%A3%E5%86%B3hexo%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="解决hexo部署到github上图片无法显示问题"><a href="#解决hexo部署到github上图片无法显示问题" class="headerlink" title="解决hexo部署到github上图片无法显示问题"></a>解决hexo部署到github上图片无法显示问题</h1><span id="more"></span>

<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>设置站点配置文件<code>_config.yml</code>中 <code>post_asset_folder:true</code></p>
<p><img src="/2021/08/11/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E8%A7%A3%E5%86%B3hexo%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/image-20210811190704876.png" alt="image-20210811190704876"></p>
<p><code>Hexo</code> 提供了一种更方便管理 <code>Asset</code> 的设定：<code>post_asset_folder</code>当您设置为<code>true</code>参数后，在建立文件时，<code>Hexo</code><strong>会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹。</strong></p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>在hexo的目录下执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>完成安装后用<code>hexo</code>新建文章的时候会发现<code>_posts</code>目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。</p>
<p>然后进行正常的<code>hexo</code>三连就可以了</p>
<h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><p>大家按照上面的步骤完成之后，在部署或者测试的时候图片可能仍然无法正常显示，这涉及到<code>hexo-asset-image</code>插件的问题。</p>
<p>如果在<code>hexo g</code>之后图片的加载是这样的：</p>
<p><img src="/2021/08/11/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E8%A7%A3%E5%86%B3hexo%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/image-20210811192905480.png" alt="image-20210811192905480"></p>
<p>带<code>/.com//d</code>的，那你的图片百分百是没法显示的。解决这个问题也很简单：</p>
<ol>
<li><p>找到<code>node_modules\hexo-asset-image</code></p>
</li>
<li><p>打开<code>index.js</code></p>
</li>
<li><p>修改24行为：</p>
</li>
</ol>
<p><img src="/2021/08/11/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E8%A7%A3%E5%86%B3hexo%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/image-20210811193248235.png" alt="image-20210811193248235"></p>
<p><img src="/2021/08/11/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E8%A7%A3%E5%86%B3hexo%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/image-20210811193519193.png" alt="image-20210811193519193"></p>
]]></content>
      <categories>
        <category>博客运维</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>fix</tag>
      </tags>
  </entry>
  <entry>
    <title>解决hexo中文乱码</title>
    <url>/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E8%A7%A3%E5%86%B3hexo%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<h2 id="解决hexo中文乱码"><a href="#解决hexo中文乱码" class="headerlink" title="解决hexo中文乱码"></a>解决hexo中文乱码</h2><span id="more"></span>

<p>出现中文乱码可能是因为配置文件中不是使用<code>utf-8</code>进行保存，因此</p>
<p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E8%A7%A3%E5%86%B3hexo%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/image-20210811160509073.png" alt="image-20210811160509073"></p>
<p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E8%A7%A3%E5%86%B3hexo%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/image-20210811160532496.png" alt="image-20210811160532496"></p>
<p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E8%A7%A3%E5%86%B3hexo%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/image-20210811160608358.png" alt="image-20210811160608358"></p>
<p>即可解决问题</p>
]]></content>
      <categories>
        <category>博客运维</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>fix</tag>
      </tags>
  </entry>
  <entry>
    <title>解决hexo标签和分类页面无法正常显示</title>
    <url>/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E8%A7%A3%E5%86%B3hexo%E6%A0%87%E7%AD%BE%E5%92%8C%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h2 id="解决hexo标签和分类页面无法正常显示"><a href="#解决hexo标签和分类页面无法正常显示" class="headerlink" title="解决hexo标签和分类页面无法正常显示"></a>解决hexo标签和分类页面无法正常显示</h2><span id="more"></span>

<p>需要找到</p>
<p><img src="/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E8%A7%A3%E5%86%B3hexo%E6%A0%87%E7%AD%BE%E5%92%8C%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA/image-20210812083030492.png" alt="image-20210812083030492"></p>
<p>打开<code>index.md</code></p>
<p>分别添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line"></span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br></pre></td></tr></table></figure>

<p>即可解决</p>
]]></content>
      <categories>
        <category>博客运维</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>fix</tag>
      </tags>
  </entry>
  <entry>
    <title>解决hexo-github hexo g time out 443</title>
    <url>/2021/08/12/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E8%A7%A3%E5%86%B3hexo%E9%83%A8%E7%BD%B2%E5%91%BD%E4%BB%A4timeout443/</url>
    <content><![CDATA[<p>最近<code>github</code>又双叒叕抽风了😣🙄😓😶😶😶😶😶</p>
<span id="more"></span>

<h2 id="观前提醒"><a href="#观前提醒" class="headerlink" title="观前提醒"></a>观前提醒</h2><p>为了解决github抽风问题，本文默认各位读者身经百战，有过多次跨栏经验。<strong>人手一个格局打开软件</strong>（￣︶￣）↗　φ(*￣0￣)</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>要解决这个问题，需要使用代理，git设置代理的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy &#x27;socks5://127.0.0.1:10808&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global https.proxy &#x27;socks5://127.0.0.1:10808&#x27;</span><br></pre></td></tr></table></figure>

<p>如果不需要代理了，则可以运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --system (或 --global 或 --local) --unset http.proxy</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --system (或 --global 或 --local) --unset https.proxy</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客运维</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>fix</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射机制</title>
    <url>/2021/08/12/Java/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>反射（Reflection），<code>java</code>语言的核心知识之一，各大框架经常使用的技术。</p>
<p>针对<code>java</code>语言，我打算出一些语言的核心知识和一些类库的使用，还有自己翻译的API，都会放在博客里面供参考。</p>
<p>各位有需要可以在tags那里点击所有以<code>java</code>开头的标签，这些标签的意义如下：</p>
<ul>
<li>java_core：核心的java知识，包括反射、泛型、注解、代理……</li>
<li>java_lib：各类java类库的使用基础，java的API，或者一些API的历史</li>
<li>java_features：java的特性，包括java的语法糖，java各版本的更新特性等</li>
<li>……</li>
</ul>
<span id="more"></span>

<h2 id="关于反射"><a href="#关于反射" class="headerlink" title="关于反射"></a>关于反射</h2><p>能够分析类能力的程序称之为反射(Reflection)</p>
<p>反射机制可以用来：</p>
<ol>
<li>在运行时分析类的能力</li>
<li>在运行时检查对象，例如：编写一个适合所有类的<code>toString()</code></li>
<li>实现泛型数组操作代码</li>
<li>利用Method对象（类似C++中的函数指针）</li>
<li>用户界面生成器</li>
</ol>
<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>在程序运行时，JRE始终为所有对象维护一个运行时类型标识<del>（个人猜测实际上是一个结构体）</del>。<strong>这个类型标识会跟踪记录每一个对象所属的类</strong>。虚拟机利用这些信息来保证调用正确的方法</p>
<p><code>Class</code>类保存了<strong>这<span style="background-color:yellow">些</span>类型标识</strong>（<code>Class</code>类是<strong>泛型类</strong>）内部的信息，因此可以使用这个特殊的类来访问这些信息。</p>
<h3 id="那么何如获取这些信息呢？"><a href="#那么何如获取这些信息呢？" class="headerlink" title="那么何如获取这些信息呢？"></a>那么何如获取这些信息呢？</h3><p>Object类中有一个<code>getClass()</code>，可以返回一个<code>Class</code>类型实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cl</span> </span>= e.getclass();</span><br></pre></td></tr></table></figure>

<p><code>class</code>类中有个方法<code>getName()</code>，可以获取对象所属的类名（字符串形式），当然如果这个类在一个包中，则返回的类名也会包含包名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ram = <span class="keyword">new</span> Random();</span><br><span class="line">Class cl = ram.getClass();</span><br><span class="line">String name = cl.getName()  </span><br><span class="line"><span class="comment">// name is &quot;java.util.Random&quot;</span></span><br></pre></td></tr></table></figure>

<p>当然java还有一种方便的方法来获取每一个类的<code>Class</code>类对象。<strong>如果<code>T</code>是任意的Java类型，则<code>T.class</code>代表该类的<code>Class</code>类对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class cl = Random.class;</span><br><span class="line">Class c2 = int[].class;</span><br><span class="line">Class c3 = int.class;		</span><br></pre></td></tr></table></figure>

<p><strong>Class对象实际上表示的是一种类型（type），这种类型可以是类，亦可以不是类，因此<code>int.class、int[].class</code>是合法的。</strong></p>
<p>如果我想实现动态加载加载类，或者我现在知道这个类的类名（或者接口名）,则还可以使用<code>Class</code>类本身的静态方法来实现类加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String classname = &quot;java.util.Random&quot;;</span><br><span class="line">try&#123;</span><br><span class="line">	Class cl = Class.forName(classname);</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若<code>classname</code>不是一个接口或者类，则会抛出检查型异常。因此捕获异常。</p>
<p>使用这种方法获得<code>Class</code>对象，<code>classname</code>对应的类会被加载，<strong>也就是说类里面的静态代码块（Static Code）会被执行</strong>。同时可以变换<code>classname</code>的值来实现动态加载类。</p>
<h3 id="更加准确的类型比较"><a href="#更加准确的类型比较" class="headerlink" title="更加准确的类型比较"></a>更加准确的类型比较</h3><p>JVM为每一种类型管理一个唯一的<code>Class</code>类对象，也就是说父类和子类被区分为不同的<code>Class</code>类型，因此可以利用<code>==</code>来进行同类型对象比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">father.getClass() == son.getClass();	// 表达式为False，即便father是son的父类</span><br></pre></td></tr></table></figure>

<h3 id="使用Class类对象构造类实例"><a href="#使用Class类对象构造类实例" class="headerlink" title="使用Class类对象构造类实例"></a>使用Class类对象构造类实例</h3><p>前文说过，<code>Class</code>类实际上表示的是一种类型，既然如此我能不能用一个<code>Class</code>类来构造一个类实例呢？答案肯定是能的</p>
<p>使用<code>getConstructor()</code>和<code>newInstance()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class cl = Class.forName(classname);</span><br><span class="line">Object obj = Cl.getConstructor().newInstance();</span><br></pre></td></tr></table></figure>

<p>那如果我想要调用有参数的构造器来创建对象呢？</p>
<p>先看看<code>getConstructor()</code>和<code>newInstance()</code>方法的声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructor getConstructor(Class ...paramterTypes)		// 生成一个构造器对象,并描述这个构造器有什么参数类型</span><br><span class="line">Object newInstance(Object ...params)					// 生成对象实例，params参数为构造器传进的参数</span><br></pre></td></tr></table></figure>

<p>因此，可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class cl = Class.forName(classname);</span><br><span class="line">Object obj = Cl.getConstructor(int.class).newInstance(25);		// 调用classname类中带int类型的构造器，并传入参数整型25</span><br></pre></td></tr></table></figure>

<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><code>Class</code>类通常也用在读入资源上，例如显示一张图片等</p>
<h3 id="加载资源的方法"><a href="#加载资源的方法" class="headerlink" title="加载资源的方法"></a>加载资源的方法</h3><p><strong>如果资源文件和类文件放在同一个包中</strong>，则可以</p>
<ul>
<li>获取资源类的<code>Class</code>对象</li>
<li>有些方法需要获取资源位置的URL则需要调用<code>getResource()</code></li>
<li>如果不想获取URL而是直接将文件的所有字节存放在输入流中的则需要调用<code>getResourceAsStream()</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class cl = ResourceTest.class;</span><br><span class="line">URL aboutURL = c1.getResource(&quot;about.png&quot;);</span><br><span class="line">Image icon = new Image(aboutURL);</span><br><span class="line"></span><br><span class="line">InputStream stream = cl.getResourceAsStream(&quot;../Date/about.txt&quot;);		// 支持相对和绝对路径，如果没找到资源则返回null</span><br><span class="line">var about = new String(stream.readAllBytes(), &quot;UTF-8&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="反射应用"><a href="#反射应用" class="headerlink" title="反射应用"></a>反射应用</h2><h3 id="利用反射分析类"><a href="#利用反射分析类" class="headerlink" title="利用反射分析类"></a>利用反射分析类</h3><p>反射机制中常用来做类分析的重要类：<code>Field</code>、<code>Method</code>、<code>Constructor</code>。这些类都在<code>java.lang.reflect</code>包中</p>
<p>接下来对这几个类用来分析的方法进行简单介绍：</p>
<h4 id="Class类-1"><a href="#Class类-1" class="headerlink" title="Class类"></a>Class类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String	  getName()						// 返回该类型的类名字</span><br><span class="line">String    getPackageName()				// 返回该类所在的包名</span><br><span class="line">Field[]   getFields()					// 返回对象的所有公共字段，包括超类的公共字段</span><br><span class="line">Field[]   getDeclaredFields()			// 返回对象的全部字段，如果类中没有字段，或者对象是基本类型或者数组，则返回0长度数组</span><br><span class="line">Class	  getSuperClass()				// 获取该类的父类Class对象</span><br><span class="line">Method[]  getMethods()					// 返回对象所属类或者接口的所有公共方法，包括超类的公共方法</span><br><span class="line">Method[]  getDeclaredMethods()			// 返回对象所属类或者接口的全部方法，不包括超类</span><br><span class="line">Constructor[] getConstructors()			// 返回这个类的所有公共构造器</span><br><span class="line">Constructor[] getDeclaredConstructors()	// 返回全部构造器</span><br></pre></td></tr></table></figure>

<h4 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String	getName()		// 返回类中的字段名（属性名）的字符串</span><br><span class="line">Class	getType()		// 返回字段的类型（int、long、Date...）</span><br><span class="line">int		getModifiers()	// 获取字段的修饰符（public、static、final...）,返回1/0的二进制标志位，可以配合reflect包中的toString（）来显示具体的修饰符</span><br><span class="line">Class	getDeclaringClass()	//获取字段所属的类对应的Class对象</span><br></pre></td></tr></table></figure>

<h4 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String	getName()		// 返回类中的方法名的字符串</span><br><span class="line">Class	getReturnType()		// 返回方法的返回值类型对应的Class对象（int、long、Date...）</span><br><span class="line">int		getModifiers()	// 获取方法的修饰符（public、static、final...）,返回1/0的二进制标志位，可以配合reflect包中的toString（）来显示具体的修饰符</span><br><span class="line">Class	getDeclaringClass()	//获取方法所属的类对应的Class对象</span><br><span class="line">Class[] getParameterTypes()	// 返回Class对象的数组，其中各个对象表示参数的类型</span><br><span class="line">Class[] getExceptionTypes() // 返回Class对象数组,其中各个对象表示该方法所抛出的异常的类型</span><br></pre></td></tr></table></figure>

<h4 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String	getName()		// 返回类中的构造方法的字符串</span><br><span class="line">int		getModifiers()	// 获取构造方法的修饰符（public、static、final...）,返回1/0的二进制标志位，可以配合reflect包中的toString（）来显示具体的修饰符</span><br><span class="line">Class	getDeclaringClass()	//获取构造方法所属的类对应的Class对象</span><br><span class="line">Class[] getParameterTypes()	// 返回Class对象的数组，其中各个对象表示参数的类型</span><br><span class="line">Class[] getExceptionTypes() // 返回Class对象数组,其中各个对象表示该方法所抛出的异常的类型</span><br></pre></td></tr></table></figure>

<h4 id="Modifier类"><a href="#Modifier类" class="headerlink" title="Modifier类"></a>Modifier类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static String toString(int modifiers)</span><br><span class="line">static boolean isAbstract(int modifiers)</span><br><span class="line">static boolean isFinal(int modifiers)</span><br><span class="line">static boolean isInterface(int modifiers)</span><br><span class="line">static boolean isNative(int modifiers)</span><br><span class="line">static boolean isPrivate(int modifiers)</span><br><span class="line">static boolean isProtected(int modifiers)</span><br><span class="line">static boolean isPublic(int modifiers)</span><br><span class="line">static boolean isStatic(int modifiers)</span><br><span class="line">static boolean isStrict(int modifiers)</span><br><span class="line">static boolean isSynchronized(int modifiers)</span><br><span class="line">static boolean isVolatile(int modifiers)</span><br></pre></td></tr></table></figure>

<p>下面将演示一个通过反射来分析一个类的demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Modifier;</span><br><span class="line">import java.security.PrivateKey;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Test(&quot;java.lang.Double&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Test(String classname)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class c = Class.forName(classname);</span><br><span class="line">            printClass(c);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void printClass(Class c)&#123;</span><br><span class="line">        Class sc = c.getSuperclass();						// 获取父类</span><br><span class="line">        String modifier = Modifier.toString(c.getModifiers());// 获取类修饰符</span><br><span class="line">        if(modifier.length()&gt;0)</span><br><span class="line">            System.out.print(modifier + &quot; &quot;);     			</span><br><span class="line">        System.out.print(&quot;class &quot; + c.getName());			// class + 类名</span><br><span class="line">        if(sc!=null &amp;&amp; sc != Object.class)</span><br><span class="line">            System.out.print(&quot; extends &quot; + sc.getName());	// 继承的父类</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;&#123;&quot;);</span><br><span class="line">        printConstructor(c);								// 获取构造器函数</span><br><span class="line">        System.out.println();</span><br><span class="line">        printField(c);										// 获取字段名</span><br><span class="line">        System.out.println();</span><br><span class="line">        printMethod(c);										// 获取方法名</span><br><span class="line">        System.out.println(&quot;&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void printField(Class c)&#123;</span><br><span class="line">        Field[] fields = c.getDeclaredFields();				// 获取字段名</span><br><span class="line">        for (Field f:fields</span><br><span class="line">             ) &#123;</span><br><span class="line">            Class type = f.getType();						// 字段类型</span><br><span class="line">            String name = f.getName();						// 字段名</span><br><span class="line">            System.out.print(&quot;    &quot;);</span><br><span class="line">            String midifier = Modifier.toString(f.getModifiers());</span><br><span class="line">            if(midifier.length()&gt;0)</span><br><span class="line">                System.out.print(midifier + &quot; &quot;);			// 字段修饰符</span><br><span class="line">            System.out.println(type.getName() + &quot; &quot; + name + &quot;;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void printConstructor(Class c)&#123;</span><br><span class="line">        Constructor[] constructors = c.getConstructors();	// 获取构造方法名称</span><br><span class="line">        for (Constructor constructor:constructors</span><br><span class="line">        ) &#123;</span><br><span class="line">            String midifier = Modifier.toString(constructor.getModifiers());</span><br><span class="line">            String methodName = constructor.getName();		// 获取构造方法名</span><br><span class="line">            Class[] Params = constructor.getParameterTypes();// 获取参数类型</span><br><span class="line">            Class[] exceptions = constructor.getExceptionTypes();	// 获取异常类型</span><br><span class="line">            System.out.print(&quot;    &quot;);</span><br><span class="line">            if(midifier.length()&gt;0)</span><br><span class="line">                System.out.print(midifier + &quot; &quot;);			// 获取修饰符</span><br><span class="line">            System.out.print(methodName + &quot;(&quot;);			 </span><br><span class="line">            for(int i=0; i&lt;Params.length; i++)&#123;</span><br><span class="line">                if(i == Params.length - 1)</span><br><span class="line">                    System.out.print( Params[i].getName());</span><br><span class="line">                else</span><br><span class="line">                    System.out.print( Params[i].getName() + &quot;, &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(&quot;)&quot;);</span><br><span class="line">            if(exceptions.length&gt;0)</span><br><span class="line">                System.out.print(&quot;throws &quot;);				// 获取异常类型</span><br><span class="line">            for(int i=0; i&lt;exceptions.length; i++)&#123;</span><br><span class="line">                if(i == exceptions.length - 1)</span><br><span class="line">                    System.out.print( exceptions[i].getName());</span><br><span class="line">                else</span><br><span class="line">                    System.out.print( exceptions[i].getName() + &quot;, &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void printMethod(Class c)&#123;</span><br><span class="line">        Method[] methods = c.getDeclaredMethods();</span><br><span class="line">        for (Method m:methods</span><br><span class="line">             ) &#123;</span><br><span class="line">            String midifier = Modifier.toString(m.getModifiers());</span><br><span class="line">            String ret = m.getReturnType().getName();</span><br><span class="line">            String methodName = m.getName();</span><br><span class="line">            Class[] Params = m.getParameterTypes();</span><br><span class="line">            Class[] exceptions = m.getExceptionTypes();</span><br><span class="line">            System.out.print(&quot;    &quot;);</span><br><span class="line">            if(midifier.length()&gt;0)</span><br><span class="line">                System.out.print(midifier + &quot; &quot;);</span><br><span class="line">            System.out.print(ret + &quot; &quot; + methodName + &quot;(&quot;);</span><br><span class="line">            for(int i=0; i&lt;Params.length; i++)&#123;</span><br><span class="line">               if(i == Params.length - 1)</span><br><span class="line">                   System.out.print( Params[i].getName());</span><br><span class="line">               else</span><br><span class="line">                   System.out.print( Params[i].getName() + &quot;, &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(&quot;)&quot;);</span><br><span class="line">            if(exceptions.length&gt;0)</span><br><span class="line">                System.out.print(&quot;throws &quot;);</span><br><span class="line">            for(int i=0; i&lt;exceptions.length; i++)&#123;</span><br><span class="line">                if(i == exceptions.length - 1)</span><br><span class="line">                    System.out.print( exceptions[i].getName());</span><br><span class="line">                else</span><br><span class="line">                    System.out.print( exceptions[i].getName() + &quot;, &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class java.lang.Double extends java.lang.Number</span><br><span class="line">&#123;</span><br><span class="line">    public java.lang.Double(double);</span><br><span class="line">    public java.lang.Double(java.lang.String)throws java.lang.NumberFormatException;</span><br><span class="line"></span><br><span class="line">    public static final double POSITIVE_INFINITY;</span><br><span class="line">    public static final double NEGATIVE_INFINITY;</span><br><span class="line">    public static final double NaN;</span><br><span class="line">    public static final double MAX_VALUE;</span><br><span class="line">    public static final double MIN_NORMAL;</span><br><span class="line">    public static final double MIN_VALUE;</span><br><span class="line">    public static final int MAX_EXPONENT;</span><br><span class="line">    public static final int MIN_EXPONENT;</span><br><span class="line">    public static final int SIZE;</span><br><span class="line">    public static final int BYTES;</span><br><span class="line">    public static final java.lang.Class TYPE;</span><br><span class="line">    private final double value;</span><br><span class="line">    private static final long serialVersionUID;</span><br><span class="line"></span><br><span class="line">    public boolean equals(java.lang.Object);</span><br><span class="line">    public static java.lang.String toString(double);</span><br><span class="line">    public java.lang.String toString();</span><br><span class="line">    public int hashCode();</span><br><span class="line">    public static int hashCode(double);</span><br><span class="line">    public static double min(double, double);</span><br><span class="line">    public static double max(double, double);</span><br><span class="line">    public static native long doubleToRawLongBits(double);</span><br><span class="line">    public static long doubleToLongBits(double);</span><br><span class="line">    public static native double longBitsToDouble(long);</span><br><span class="line">    public volatile int compareTo(java.lang.Object);</span><br><span class="line">    public int compareTo(java.lang.Double);</span><br><span class="line">    public byte byteValue();</span><br><span class="line">    public short shortValue();</span><br><span class="line">    public int intValue();</span><br><span class="line">    public long longValue();</span><br><span class="line">    public float floatValue();</span><br><span class="line">    public double doubleValue();</span><br><span class="line">    public static java.lang.Double valueOf(double);</span><br><span class="line">    public static java.lang.Double valueOf(java.lang.String)throws java.lang.NumberFormatException;</span><br><span class="line">    public static java.lang.String toHexString(double);</span><br><span class="line">    public static int compare(double, double);</span><br><span class="line">    public java.lang.Double resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup);</span><br><span class="line">    public volatile java.lang.Object resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup)throws java.lang.ReflectiveOperationException;</span><br><span class="line">    public java.util.Optional describeConstable();</span><br><span class="line">    public static boolean isNaN(double);</span><br><span class="line">    public boolean isNaN();</span><br><span class="line">    public static boolean isInfinite(double);</span><br><span class="line">    public boolean isInfinite();</span><br><span class="line">    public static boolean isFinite(double);</span><br><span class="line">    public static double sum(double, double);</span><br><span class="line">    public static double parseDouble(java.lang.String)throws java.lang.NumberFormatException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="利用反射在运行时分析对象"><a href="#利用反射在运行时分析对象" class="headerlink" title="利用反射在运行时分析对象"></a>利用反射在运行时分析对象</h3><p>前文讲过如何利用反射分析一个类的组成，那么对于类运行时的实例而言，能不能获取到对象实例的具体值呢？能</p>
<p>要做到这一点，需要用到<code>Field</code>类中的<code>get()</code>和<code>set()</code>（同样<code>Method</code>类、<code>Constructor</code>类也有这个方法），例如看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var harry = new Employee(&quot;Harry Hacker&quot;, 50000, 10, 1, 1989);</span><br><span class="line">Class cl = harry.getClass();</span><br><span class="line">Field f = cl.getDeclaredField(&quot;name&quot;);</span><br><span class="line">// the &#x27;name&#x27; field of the Employee class</span><br><span class="line">object v = f.get(harry);		// 获取harry对象中字段为name的值</span><br><span class="line">// output:“Harry Hacker”</span><br></pre></td></tr></table></figure>

<p>同样更改值，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f.set(harry, &quot;Askia&quot;);		// 设置harry对象中字段为name的值</span><br></pre></td></tr></table></figure>

<p>当然上面的<code>get()</code>、<code>set()</code>代码存在问题，因为<code>name</code>字段修饰符是<code>private</code>，因此对该字段的值进行访问会抛出<code>illegalAccessException</code>。</p>
<p><strong>Java安全机制允许查看一个对象有哪些字段，但是除非拥有访问权限，否则不能对这些字段进行读写。</strong></p>
<p>那么就真的没有办法对这些字段进行强制修改了吗？也不是，我们可以调用<code>setAccessible()</code>来覆盖java的访问控制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f.setAccessible(true);</span><br><span class="line">f.set(harry, &quot;Askia&quot;);</span><br><span class="line">// now harry.name is &quot;Askia&quot;</span><br></pre></td></tr></table></figure>

<h4 id="通用的toString"><a href="#通用的toString" class="headerlink" title="通用的toString()"></a>通用的<code>toString()</code></h4><p>通用的<code>toString()</code>方法通过使用<code>getDeclaredFileds()</code>获得所有的数据字段，然后使用<code>setAccessible</code>方法将所有字段设置为可访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ObjectAnalyzer&#123;</span><br><span class="line">	private ArrayList&lt;Object&gt; visited = new ArrayList&lt;&gt;();</span><br><span class="line">	 </span><br><span class="line">	public String toString(Object obj) throws ReflectiveOperationException&#123;</span><br><span class="line">		if(obj == null)&#123;</span><br><span class="line">			return &quot;null&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		if(visited.contains(obj))&#123;</span><br><span class="line">			return &quot;...&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		visited.add(obj);</span><br><span class="line">		Class cl = obj.getClass();</span><br><span class="line">		if(cl == String.class)&#123;</span><br><span class="line">			return (String)obj;</span><br><span class="line">		&#125;</span><br><span class="line">		if(cl.isArray())&#123;</span><br><span class="line">			String r = cl.getComponentType() + &quot;[]&#123;&quot;;</span><br><span class="line">			for(int i = 0; i&lt; Array.getLength(obj); i++)&#123;</span><br><span class="line">				if(i &gt; 0) r+=&quot;,&quot;;</span><br><span class="line">				Object val = Array.get(obj, i);</span><br><span class="line">				if(cl.getComponentType().isPrimitive())&#123;</span><br><span class="line">						r += val;</span><br><span class="line">				&#125;else&#123;</span><br><span class="line">						r += toString(val);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return r + &quot;&#125;&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		String r = cl.getName();</span><br><span class="line">		</span><br><span class="line">		do&#123;</span><br><span class="line">			r+=&quot;[&quot;;</span><br><span class="line">			Field[] fields = cl.getDeclaredFields();</span><br><span class="line">			AccessibleObject.setAccessible(fields, true);</span><br><span class="line">			</span><br><span class="line">			for(Field f:fields)&#123;</span><br><span class="line">				if(!Modifier.isStatic(f.getModifiers()))&#123;</span><br><span class="line">					if(!r.endsWith(&quot;[&quot;))	r+=&quot;,&quot;;</span><br><span class="line">					r+=f.getName() +&quot;=&quot;;</span><br><span class="line">					Class t = f.getType();</span><br><span class="line">					Object val = f.get(obj);</span><br><span class="line">					if(t.isPrimitive())	r+=val;</span><br><span class="line">					else r+= toString(val);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			r+=&quot;]&quot;;</span><br><span class="line">			cl = cl.getSuperclass();</span><br><span class="line">		&#125;while(cl!=null);</span><br><span class="line">		return r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用反射调用任意的方法和构造器"><a href="#使用反射调用任意的方法和构造器" class="headerlink" title="使用反射调用任意的方法和构造器"></a>使用反射调用任意的方法和构造器</h3><p><code>Method</code>类中有一个<code>invoke()</code>方法,用于调用对象中的方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object ...args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数是隐式参数,传入一个包含此方法的对象，对于静态方法可以置null，第二个参数是要传入的数据，对于基本类型，请使用包装类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Employee harry;</span><br><span class="line">me.invoke(harry, harry);		// 调用harry对象中的createdObject(Employee e)方法，见下文代码</span><br></pre></td></tr></table></figure>

<p>要获取与所需要的方法对应的Method对象,有两种方法:</p>
<ul>
<li>调用GetDeclareMethods()，在返回的Methods[]中寻找</li>
<li>调用GetMethod()</li>
</ul>
<p>第二种方法需要指定<strong>要调用的方法的方法名和参数类型</strong>（可能会重载，一次单一方法名不能判断是哪个方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, Class ...parameterTypes)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method me = Beans.class.getMethod(<span class="string">&quot;createdObject&quot;</span>, Employee.class);</span><br></pre></td></tr></table></figure>

<p>同样，对于构造方法的获取，也需要指定<strong>参数类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cl = Random.class;</span><br><span class="line">Constructor cons = cl.getConstructor(<span class="keyword">long</span>.class);	<span class="comment">// 获取参数类型为long的构造器</span></span><br><span class="line">Object obj = cons.newInstance(<span class="number">42L</span>);</span><br><span class="line"><span class="comment">// 传递参数并调用构造方法</span></span><br></pre></td></tr></table></figure>

<p>下面的小demo演示了如何调用任意的方法和构造器</p>
<p><strong>注意：使用该方法调用对象方法，效率非常慢，因此除非必要，否则不建议使用，特别是回调的Method对象！</strong></p>
<h3 id="使用反射编写泛型数组代码"><a href="#使用反射编写泛型数组代码" class="headerlink" title="使用反射编写泛型数组代码"></a>使用反射编写泛型数组代码</h3><p>java.lang.reflect包中有一个<code>Array</code>类，可用于动态创建数组（通常用于增容或者缩减数组），他的伴随类Arrays中的copyOf就是该类的最好示例。要动态创建一个新数组，你可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object newArray = Array.newInstance(componentType, newlength);</span><br></pre></td></tr></table></figure>

<p>在动态创建数组，一般遵循以下步骤：</p>
<ol>
<li>获取参数a的类对象</li>
<li>确定a是一个数组</li>
<li>获取a的数组类型</li>
</ol>
<p>可参考下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">goodCopyOf</span><span class="params">(Object a, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">	Class cl = a.getClass();						<span class="comment">// 获取a的类对象</span></span><br><span class="line">	<span class="keyword">if</span>(!cl.isArray())								<span class="comment">// 确定a是一个数组</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	Class componentType = cl.getComponentType();	<span class="comment">// 获取a的数组类型</span></span><br><span class="line">	<span class="keyword">int</span> length = Array.getLength(a);</span><br><span class="line">	Object newArray = Array.newInstance(componentType, length);			<span class="comment">//创建数组</span></span><br><span class="line">	System.arrayCopy(a, <span class="number">0</span>, newArray, <span class="number">0</span>, Mah.min(length, newLength));	<span class="comment">// 复制数组</span></span><br><span class="line">	<span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h2><h3 id="Class类-2"><a href="#Class类-2" class="headerlink" title="Class类"></a>Class类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String	  getName()						// 返回该类型的类名字</span><br><span class="line">String    getPackageName()				// 返回该类所在的包名</span><br><span class="line">Field[]   getFields()					// 返回对象的所有公共字段，包括超类的公共字段</span><br><span class="line">Field[]   getDeclaredFields()			// 返回对象的全部字段，如果类中没有字段，或者对象是基本类型或者数组，则返回0长度数组</span><br><span class="line">Class	  getSuperClass()				// 获取该类的父类Class对象</span><br><span class="line">Method[]  getMethods()					// 返回对象所属类或者接口的所有公共方法，包括超类的公共方法</span><br><span class="line">Method[]  getDeclaredMethods()			// 返回对象所属类或者接口的全部方法，不包括超类</span><br><span class="line">Constructor[] getConstructors()			// 返回这个类的所有公共构造器</span><br><span class="line">Constructor[] getDeclaredConstructors()	// 返回全部构造器</span><br></pre></td></tr></table></figure>

<h3 id="Field类-1"><a href="#Field类-1" class="headerlink" title="Field类"></a>Field类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String	getName()		// 返回类中的字段名（属性名）的字符串</span><br><span class="line">Class	getType()		// 返回字段的类型（int、long、Date...）</span><br><span class="line">int		getModifiers()	// 获取字段的修饰符（public、static、final...）,返回1/0的二进制标志位，可以配合reflect包中的toString（）来显示具体的修饰符</span><br><span class="line">Class	getDeclaringClass()	//获取字段所属的类对应的Class对象</span><br></pre></td></tr></table></figure>

<h3 id="Method类-1"><a href="#Method类-1" class="headerlink" title="Method类"></a>Method类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String	getName()		// 返回类中的方法名的字符串</span><br><span class="line">Class	getReturnType()		// 返回方法的返回值类型对应的Class对象（int、long、Date...）</span><br><span class="line">int		getModifiers()	// 获取方法的修饰符（public、static、final...）,返回1/0的二进制标志位，可以配合reflect包中的toString（）来显示具体的修饰符</span><br><span class="line">Class	getDeclaringClass()	//获取方法所属的类对应的Class对象</span><br><span class="line">Class[] getParameterTypes()	// 返回Class对象的数组，其中各个对象表示参数的类型</span><br><span class="line">Class[] getExceptionTypes() // 返回Class对象数组,其中各个对象表示该方法所抛出的异常的类型</span><br><span class="line">Object invoke(Object obj, Object ...args)		// 执行该方法！</span><br></pre></td></tr></table></figure>

<h3 id="Constructor类-1"><a href="#Constructor类-1" class="headerlink" title="Constructor类"></a>Constructor类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String	getName()		// 返回类中的构造方法的字符串</span><br><span class="line">int		getModifiers()	// 获取构造方法的修饰符（public、static、final...）,返回1/0的二进制标志位，可以配合reflect包中的toString（）来显示具体的修饰符</span><br><span class="line">Class	getDeclaringClass()	//获取构造方法所属的类对应的Class对象</span><br><span class="line">Class[] getParameterTypes()	// 返回Class对象的数组，其中各个对象表示参数的类型</span><br><span class="line">Class[] getExceptionTypes() // 返回Class对象数组,其中各个对象表示该方法所抛出的异常的类型</span><br></pre></td></tr></table></figure>

<h3 id="Modifier类-1"><a href="#Modifier类-1" class="headerlink" title="Modifier类"></a>Modifier类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static String toString(int modifiers)</span><br><span class="line">static boolean isAbstract(int modifiers)</span><br><span class="line">static boolean isFinal(int modifiers)</span><br><span class="line">static boolean isInterface(int modifiers)</span><br><span class="line">static boolean isNative(int modifiers)</span><br><span class="line">static boolean isPrivate(int modifiers)</span><br><span class="line">static boolean isProtected(int modifiers)</span><br><span class="line">static boolean isPublic(int modifiers)</span><br><span class="line">static boolean isStatic(int modifiers)</span><br><span class="line">static boolean isStrict(int modifiers)</span><br><span class="line">static boolean isSynchronized(int modifiers)</span><br><span class="line">static boolean isVolatile(int modifiers)</span><br></pre></td></tr></table></figure>

<h3 id="AccessibleObject类"><a href="#AccessibleObject类" class="headerlink" title="AccessibleObject类"></a>AccessibleObject类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setAccessible(boolean flag)		//设置或者取消这个可访问对象的可访问标志，如果拒接访问抛出一个IllegalAccessException</span><br><span class="line">boolean trySetAccessible()				// 尝试为在这个可访问的对象设置可访问标志，如果拒绝返回false</span><br><span class="line">boolean isAccessible()				// 是否可访问</span><br><span class="line">static void setAccessible(Object[] array, boolean flag)									// 设置一个对象数组的可访问标志。</span><br></pre></td></tr></table></figure>

<h3 id="Array类"><a href="#Array类" class="headerlink" title="Array类"></a>Array类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static Object get(Object array, int index)</span><br><span class="line">static XXX getXXX(Object array, int index)</span><br><span class="line">// 获取数组中下标为index的值，其中XXX指的是8种基本类型</span><br><span class="line"></span><br><span class="line">static void set(Object array, int index, Object newValue)</span><br><span class="line">static void setXXXO(Object array, int index, XXX newValue)</span><br><span class="line">// 设置数组中下标为index的新值，其中XXX指的是8种基本类型</span><br><span class="line"></span><br><span class="line">static int getLength(Object array)	// 返回给定数组长度</span><br><span class="line"></span><br><span class="line">static Object newInstance(Class comonentType, int length)</span><br><span class="line">static Object newInstance(Class componentType, int[] lengths)</span><br><span class="line">// 创建特定类型、长度的数组</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java学习笔记</category>
      </categories>
      <tags>
        <tag>java_core</tag>
        <tag>java_lib</tag>
        <tag>java_features</tag>
      </tags>
  </entry>
  <entry>
    <title>Java IO</title>
    <url>/2021/08/12/Java/JavaIO%E6%B5%81/</url>
    <content><![CDATA[<p><em><del>Java将IO流设计得非常好用，在深入Java之后，除了Java容器（JCF）的源代码之外，最好也去看下IO流的设计。</del></em></p>
<p>Java IO流，<code>java</code>语言的核心知识之一，在开发中需要用到外部资源时经常会和它打交道。</p>
<p>针对<code>java</code>语言，我打算出一些语言的核心知识和一些类库的使用，还有自己翻译的API，都会放在博客里面供参考。</p>
<p>各位有需要可以在tags那里点击所有以<code>java</code>开头的标签，这些标签的意义如下：</p>
<ul>
<li>java_core：核心的java知识，包括反射、泛型、注解、代理……</li>
<li>java_lib：各类java类库的使用基础，java的API，或者一些API的历史</li>
<li>java_features：java的特性，包括java的语法糖，java各版本的更新特性等</li>
<li>……</li>
</ul>
<span id="more"></span>

<h2 id="文件目录操作及简单文件读写"><a href="#文件目录操作及简单文件读写" class="headerlink" title="文件目录操作及简单文件读写"></a>文件目录操作及简单文件读写</h2><h3 id="接口Path"><a href="#接口Path" class="headerlink" title="接口Path"></a>接口Path</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Path</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Path</span>&gt;, <span class="title">Iterable</span>&lt;<span class="title">Path</span>&gt;, <span class="title">Watchable</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>java.nio.file.Path</li>
</ul>
<p>表示的是一个目录名，其后还可以跟着一个文件名。路径中的第一个是根部件，例如：<code>/</code>或者<code>D:\</code>，该接口还有一个伴随类<code>Paths</code>。</p>
<p>此接口仅用于开发自定义文件系统实现的那些实现。可以实现该接口给出自己的文件<code>Path</code>代码</p>
<h3 id="伴随类Paths"><a href="#伴随类Paths" class="headerlink" title="伴随类Paths"></a>伴随类Paths</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Paths</span> <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>java.nio.file.Paths</li>
</ul>
<p><code>Path</code>接口的伴随类，可以通过该类直接创建<code>Path</code>对象</p>
<h3 id="Files类"><a href="#Files类" class="headerlink" title="Files类"></a>Files类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Files</span> <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>java.nio.file.Files </li>
</ul>
<p>该类只包含对文件，目录或者其他类型文件进行操作的静态方法，可以说是类<code>File</code>的升级版，对<code>File</code>提供了更加有效和扩展的功能补充，非常方便。</p>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">File</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>java.io.File </li>
</ul>
<p>旧版本的文件目录类。和<code>Path</code>一样的功能</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="Path接口"><a href="#Path接口" class="headerlink" title="Path接口"></a>Path接口</h4><table>
<thead>
<tr>
<th>返回值</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>compareTo(Path other)</code>  <br>比较两个抽象的路径词典。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>endsWith(Path other)</code> <br> 测试此路径是否以给定的路径结束。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>endsWith(String other)</code> <br> 测试此路径是否以 <code>Path</code>结束，通过转换给定的路径字符串，完全按照 <a href="../../../java/nio/file/Path.html#endsWith-java.nio.file.Path-"><code>endsWith(Path)</code></a>方法指定的方式构建。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>equals(Object other)</code>  <br>测试此路径与给定对象的相等性。</td>
</tr>
<tr>
<td><code>Path</code></td>
<td><code>getFileName()</code>  <br>将此路径表示的文件或目录的名称返回为 <code>Path</code>对象。</td>
</tr>
<tr>
<td><code>FileSystem</code></td>
<td><code>getFileSystem()</code>  <br>返回创建此对象的文件系统。</td>
</tr>
<tr>
<td><code>Path</code></td>
<td><code>getName(int index)</code>  <br>返回此路径的名称元素作为 <code>Path</code>对象。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getNameCount()</code>  <br>返回路径中的名称元素的数量。</td>
</tr>
<tr>
<td><code>Path</code></td>
<td><code>getParent()</code>  <br>返回 <em>父路径</em> ，或 <code>null</code>如果此路径没有父。</td>
</tr>
<tr>
<td><code>Path</code></td>
<td><code>getRoot()</code>  <br>返回此路径的根组分作为 <code>Path</code>对象，或 <code>null</code>如果该路径不具有根组件。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>hashCode()</code> <br> 计算此路径的哈希码。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isAbsolute()</code>  <br>告诉这条路是否是绝对的。</td>
</tr>
<tr>
<td><code>Iterator&lt;Path&gt;</code></td>
<td><code>iterator()</code>  <br>返回此路径的名称元素的迭代器。</td>
</tr>
<tr>
<td><code>Path</code></td>
<td><code>normalize()</code>  <br>返回一个路径，该路径是冗余名称元素的消除。</td>
</tr>
<tr>
<td><code>WatchKey</code></td>
<td><code>register(WatchService watcher, WatchEvent.Kind&lt;?&gt;... events)</code>  <br>使用手表服务注册此路径所在的文件。</td>
</tr>
<tr>
<td><code>WatchKey</code></td>
<td><code>register(WatchService watcher, WatchEvent.Kind&lt;?&gt;[] events,  WatchEvent.Modifier... modifiers)</code>  <br>使用手表服务注册此路径所在的文件。</td>
</tr>
<tr>
<td><code>Path</code></td>
<td><code>relativize(Path other)</code>  <br>构造此路径和给定路径之间的相对路径。</td>
</tr>
<tr>
<td><code>Path</code></td>
<td><code>resolve(Path other)</code>  <br>根据这条路径解决给定的路径。</td>
</tr>
<tr>
<td><code>Path</code></td>
<td><code>resolve(String other)</code><br>  一个给定的路径字符串转换为 <code>Path</code>并解析它针对此  <code>Path</code>在完全按规定的方式 <a href="../../../java/nio/file/Path.html#resolve-java.nio.file.Path-"><code>resolve</code></a>方法。</td>
</tr>
<tr>
<td><code>Path</code></td>
<td><code>resolveSibling(Path other)</code>  <br>根据此路径的 <a href="../../../java/nio/file/Path.html#getParent--"><code>parent</code></a>路径解决给定的路径。</td>
</tr>
<tr>
<td><code>Path</code></td>
<td><code>resolveSibling(String other)</code>  <br>将给定的路径字符串转换为 <code>Path</code> ，并按照 <a href="../../../java/nio/file/Path.html#resolveSibling-java.nio.file.Path-"><code>resolveSibling</code></a>方法指定的方式将其解析为该路径的  <a href="../../../java/nio/file/Path.html#getParent--"><code>parent</code></a>路径。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>startsWith(Path other)</code>  <br>测试此路径是否以给定的路径开始。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>startsWith(String other)</code>  <br>测试此路径是否以 <code>Path</code> ，通过转换给定的路径字符串，按照 <a href="../../../java/nio/file/Path.html#startsWith-java.nio.file.Path-"><code>startsWith(Path)</code></a>方法指定的方式构建。</td>
</tr>
<tr>
<td><code>Path</code></td>
<td><code>subpath(int beginIndex,  int endIndex)</code>  <br>返回一个相对的 <code>Path</code> ，它是该路径的名称元素的子序列。</td>
</tr>
<tr>
<td><code>Path</code></td>
<td><code>toAbsolutePath()</code>  <br>返回表示此路径的绝对路径的 <code>Path</code>对象。</td>
</tr>
<tr>
<td><code>File</code></td>
<td><code>toFile()</code>  <br>返回表示此路径的<a href="../../../java/io/File.html"><code>File</code></a>对象。</td>
</tr>
<tr>
<td><code>Path</code></td>
<td><code>toRealPath(LinkOption... options)</code>  <br>返回现有文件的 <em>真实</em>路径。</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>toString()</code>  <br>返回此路径的字符串表示形式。</td>
</tr>
<tr>
<td><code>URI</code></td>
<td><code>toUri()</code>  <br>返回一个URI来表示此路径。</td>
</tr>
</tbody></table>
<h4 id="Paths"><a href="#Paths" class="headerlink" title="Paths"></a>Paths</h4><table>
<thead>
<tr>
<th>返回值</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Path</code></td>
<td><code>get(String first, String... more)</code>  <br>将路径字符串或连接到路径字符串的字符串序列转换为 <code>Path</code> 。</td>
</tr>
<tr>
<td><code>static Path</code></td>
<td><code>get(URI uri)</code>  <br>将给定的URI转换为<a href="../../../java/nio/file/Path.html"><code>Path</code></a>对象。</td>
</tr>
</tbody></table>
<h4 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h4><h5 id="文件、目录创建"><a href="#文件、目录创建" class="headerlink" title="文件、目录创建"></a>文件、目录创建</h5><table>
<thead>
<tr>
<th align="left">返回值</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static Path</code></td>
<td><code>createDirectories(Path dir, FileAttribute&lt;?&gt;... attrs)</code> <br> 首先创建所有不存在的父目录来创建目录。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>createDirectory(Path dir, FileAttribute&lt;?&gt;... attrs)</code> <br> 创建一个新的目录。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>createFile(Path path, FileAttribute&lt;?&gt;... attrs)</code>  <br>创建一个新的和空的文件，如果该文件已存在失败。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>createLink(Path link, Path existing)</code>  <br>为现有文件创建新的链接（目录条目） <em>（可选操作）</em> 。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>createSymbolicLink(Path link, Path target, FileAttribute&lt;?&gt;... attrs)</code>  <br>创建到目标的符号链接 <em>（可选操作）</em> 。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>createTempDirectory(Path dir, String prefix, FileAttribute&lt;?&gt;... attrs)</code>  <br>在指定的目录中创建一个新目录，使用给定的前缀生成其名称。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>createTempDirectory(String prefix, FileAttribute&lt;?&gt;... attrs)</code>  <br>在默认临时文件目录中创建一个新目录，使用给定的前缀生成其名称。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>createTempFile(Path dir, String prefix, String suffix, FileAttribute&lt;?&gt;... attrs)</code>  <br>在指定的目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>createTempFile(String prefix, String suffix, FileAttribute&lt;?&gt;... attrs)</code>  <br>在默认临时文件目录中创建一个空文件，使用给定的前缀和后缀生成其名称。</td>
</tr>
</tbody></table>
<h5 id="文件、目录复制、移动、删除"><a href="#文件、目录复制、移动、删除" class="headerlink" title="文件、目录复制、移动、删除"></a>文件、目录复制、移动、删除</h5><table>
<thead>
<tr>
<th align="left">返回值</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static long</code></td>
<td><code>copy(InputStream in, Path target, CopyOption... options)</code>  <br>将输入流中的所有字节复制到文件。</td>
</tr>
<tr>
<td align="left"><code>static long</code></td>
<td><code>copy(Path source, OutputStream out)</code>  <br>将文件中的所有字节复制到输出流。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>copy(Path source, Path target, CopyOption... options)</code> <br> 将文件复制到目标文件。</td>
</tr>
<tr>
<td align="left"><code>static void</code></td>
<td><code>delete(Path path)</code>  <br>删除文件。</td>
</tr>
<tr>
<td align="left"><code>static boolean</code></td>
<td><code>deleteIfExists(Path path)</code>  <br>删除文件（如果存在）。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>move(Path source, Path target, CopyOption... options)</code>  <br>将文件移动或重命名为目标文件。</td>
</tr>
</tbody></table>
<h5 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h5><table>
<thead>
<tr>
<th align="left">返回值</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static boolean</code></td>
<td><code>exists(Path path, LinkOption... options)</code>  <br>测试文件是否存在。</td>
</tr>
<tr>
<td align="left"><code>static boolean</code></td>
<td><code>notExists(Path path, LinkOption... options)</code>  <br>测试此路径所在的文件是否不存在。</td>
</tr>
<tr>
<td align="left"><code>static Object</code></td>
<td><code>getAttribute(Path path, String attribute, LinkOption... options)</code>  <br>读取文件属性的值。</td>
</tr>
<tr>
<td align="left"><code>static &lt;V extends FileAttributeView&gt;V</code></td>
<td><code>getFileAttributeView(Path path, 类&lt;V&gt; type, LinkOption... options)</code> <br> 返回给定类型的文件属性视图。</td>
</tr>
<tr>
<td align="left"><code>static FileStore</code></td>
<td><code>getFileStore(Path path)</code>  <br>返回表示文件所在文件存储<a href="../../../java/nio/file/FileStore.html">区的</a>  <code>FileStore</code>。</td>
</tr>
<tr>
<td align="left"><code>static FileTime</code></td>
<td><code>getLastModifiedTime(Path path, LinkOption... options)</code>  <br>返回文件的上次修改时间。</td>
</tr>
<tr>
<td align="left"><code>static UserPrincipal</code></td>
<td><code>getOwner(Path path, LinkOption... options)</code> <br> 返回文件的所有者。</td>
</tr>
<tr>
<td align="left"><code>static Set&lt;PosixFilePermission&gt;</code></td>
<td><code>getPosixFilePermissions(Path path, LinkOption... options)</code>  <br>返回文件的POSIX文件权限。</td>
</tr>
<tr>
<td align="left"><code>static boolean</code></td>
<td><code>isDirectory(Path path, LinkOption... options)</code> <br> 测试文件是否是目录。</td>
</tr>
<tr>
<td align="left"><code>static boolean</code></td>
<td><code>isExecutable(Path path)</code>  <br>测试文件是否可执行。</td>
</tr>
<tr>
<td align="left"><code>static boolean</code></td>
<td><code>isHidden(Path path)</code>  <br>告知文件是否被 <em>隐藏</em> 。</td>
</tr>
<tr>
<td align="left"><code>static boolean</code></td>
<td><code>isReadable(Path path)</code>  <br>测试文件是否可读。</td>
</tr>
<tr>
<td align="left"><code>static boolean</code></td>
<td><code>isRegularFile(Path path, LinkOption... options)</code>  <br>测试文件是否是具有不透明内容的常规文件。</td>
</tr>
<tr>
<td align="left"><code>static boolean</code></td>
<td><code>isSameFile(Path path, Path path2)</code> <br> 测试两个路径是否找到相同的文件。</td>
</tr>
<tr>
<td align="left"><code>static boolean</code></td>
<td><code>isSymbolicLink(Path path)</code>  <br>测试文件是否是符号链接。</td>
</tr>
<tr>
<td align="left"><code>static boolean</code></td>
<td><code>isWritable(Path path)</code>  <br>测试文件是否可写。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>setAttribute(Path path, String attribute, Object value, LinkOption... options)</code>  设置文件属性的值。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>setLastModifiedTime(Path path, FileTime time)</code>  <br>更新文件上次修改的时间属性。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>setOwner(Path path, UserPrincipal owner)</code>  <br>更新文件所有者。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>setPosixFilePermissions(Path path, Set&lt;PosixFilePermission&gt; perms)</code>  <br>设置文件的POSIX权限。</td>
</tr>
<tr>
<td align="left"><code>static long</code></td>
<td><code>size(Path path)</code>  <br>返回文件的大小（以字节为单位）。</td>
</tr>
<tr>
<td align="left"><code>static &lt;A extends BasicFileAttributes&gt;A</code></td>
<td><code>readAttributes(Path path, 类&lt;A&gt; type, LinkOption... options)</code>  <br>读取文件的属性作为批量操作。</td>
</tr>
<tr>
<td align="left"><code>static Map&lt;String,Object&gt;</code></td>
<td><code>readAttributes(Path path, String attributes, LinkOption... options)</code>  <br>读取一组文件属性作为批量操作。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>readSymbolicLink(Path link)</code>  <br>读取符号链接的目标 <em>（可选操作）</em> 。</td>
</tr>
</tbody></table>
<h5 id="快速new"><a href="#快速new" class="headerlink" title="快速new"></a>快速new</h5><table>
<thead>
<tr>
<th align="left">返回值</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static BufferedReader</code></td>
<td><code>newBufferedReader(Path path)</code>  <br>打开一个文件进行阅读，返回一个 <code>BufferedReader</code>以高效的方式从文件读取文本。</td>
</tr>
<tr>
<td align="left"><code>static BufferedReader</code></td>
<td><code>newBufferedReader(Path path, Charset cs)</code> <br> 打开一个文件进行阅读，返回一个 <code>BufferedReader</code> ，可以用来以有效的方式从文件读取文本。</td>
</tr>
<tr>
<td align="left"><code>static BufferedWriter</code></td>
<td><code>newBufferedWriter(Path path, Charset cs, OpenOption... options)</code>  <br>打开或创建一个写入文件，返回一个 <code>BufferedWriter</code>  ，可以用来以有效的方式将文本写入文件。</td>
</tr>
<tr>
<td align="left"><code>static BufferedWriter</code></td>
<td><code>newBufferedWriter(Path path, OpenOption... options)</code> <br> 打开或创建一个写入文件，返回一个 <code>BufferedWriter</code>以高效的方式写入文件。</td>
</tr>
<tr>
<td align="left"><code>static SeekableByteChannel</code></td>
<td><code>newByteChannel(Path path, OpenOption... options)</code> <br> 打开或创建文件，返回可访问的字节通道以访问该文件。</td>
</tr>
<tr>
<td align="left"><code>static SeekableByteChannel</code></td>
<td><code>newByteChannel(Path path, Set&lt;?  extends OpenOption&gt; options, FileAttribute&lt;?&gt;... attrs)</code><br>  打开或创建文件，返回可访问的字节通道以访问该文件。</td>
</tr>
<tr>
<td align="left"><code>static DirectoryStream&lt;Path&gt;</code></td>
<td><code>newDirectoryStream(Path dir)</code>  <br>打开一个目录，返回一个<a href="../../../java/nio/file/DirectoryStream.html"><code>DirectoryStream</code></a>以遍历<a href="../../../java/nio/file/DirectoryStream.html">目录</a>中的所有条目。</td>
</tr>
<tr>
<td align="left"><code>static DirectoryStream&lt;Path&gt;</code></td>
<td><code>newDirectoryStream(Path dir, DirectoryStream.Filter&lt;?  super Path&gt; filter)</code>  <br>打开一个目录，返回一个<a href="../../../java/nio/file/DirectoryStream.html"><code>DirectoryStream</code></a>来迭代<a href="../../../java/nio/file/DirectoryStream.html">目录</a>中的条目。</td>
</tr>
<tr>
<td align="left"><code>static DirectoryStream&lt;Path&gt;</code></td>
<td><code>newDirectoryStream(Path dir, String glob)</code>  <br>打开一个目录，返回一个<a href="../../../java/nio/file/DirectoryStream.html"><code>DirectoryStream</code></a>来迭代<a href="../../../java/nio/file/DirectoryStream.html">目录</a>中的条目。</td>
</tr>
<tr>
<td align="left"><code>static InputStream</code></td>
<td><code>newInputStream(Path path, OpenOption... options)</code> <br> 打开一个文件，返回输入流以从文件中读取。</td>
</tr>
<tr>
<td align="left"><code>static OutputStream</code></td>
<td><code>newOutputStream(Path path, OpenOption... options)</code> <br> 打开或创建文件，返回可用于向文件写入字节的输出流。</td>
</tr>
</tbody></table>
<h5 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h5><table>
<thead>
<tr>
<th align="left">返回值</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static Stream&lt;String&gt;</code></td>
<td><code>lines(Path path)</code>  <br>从 <code>Stream</code>读取文件中的所有行。</td>
</tr>
<tr>
<td align="left"><code>static Stream&lt;String&gt;</code></td>
<td><code>lines(Path path, Charset cs)</code>  <br>从文件中读取所有行作为 <code>Stream</code> 。</td>
</tr>
<tr>
<td align="left"><code>static byte[]</code></td>
<td><code>readAllBytes(Path path)</code>  <br>读取文件中的所有字节。</td>
</tr>
<tr>
<td align="left"><code>static String</code></td>
<td><code>readString(Path path, Charset cs)</code><br>读一段文本</td>
</tr>
<tr>
<td align="left"><code>static String</code></td>
<td><code>readString(Path path)</code><br>读一段文本</td>
</tr>
<tr>
<td align="left"><code>static List&lt;String&gt;</code></td>
<td><code>readAllLines(Path path)</code>  <br>从文件中读取所有行。</td>
</tr>
<tr>
<td align="left"><code>static List&lt;String&gt;</code></td>
<td><code>readAllLines(Path path, Charset cs)</code>  <br>从文件中读取所有行。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>write(Path path, byte[] bytes, OpenOption... options)</code> <br> 将字节写入文件。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>write(Path path, Iterable&lt;? extends CharSequence&gt; lines, Charset cs, OpenOption... options)</code>  <br>将文本行写入文件。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>write(Path path, Iterable&lt;? extends CharSequence&gt; lines, OpenOption... options)</code>  <br>将文本行写入文件。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>writeString(Path path, CharSequence csq, Charset cs, OpenOption... options)</code><br>写出字符串</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>writeString(Path path, CharSequence csq, OpenOption... options)</code><br>写出字符串</td>
</tr>
</tbody></table>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><table>
<thead>
<tr>
<th align="left">返回值</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static String</code></td>
<td><code>probeContentType(Path path)</code>  <br>探测文件的内容类型。</td>
</tr>
<tr>
<td align="left"><code>static Stream&lt;Path&gt;</code></td>
<td><code>list(Path dir)</code>  <br>返回一个懒惰的填充 <code>Stream</code> ，其元素是 <code>Stream</code>中的条目。</td>
</tr>
<tr>
<td align="left"><code>static Stream&lt;Path&gt;</code></td>
<td><code>walk(Path start, FileVisitOption... options)</code>  <br>返回一个 <code>Stream</code> ，它通过  <code>Path</code>根据给定的起始文件的文件树懒惰地填充 <code>Path</code> 。</td>
</tr>
<tr>
<td align="left"><code>static Stream&lt;Path&gt;</code></td>
<td><code>walk(Path start, int maxDepth, FileVisitOption... options)</code>  <br>返回一个 <code>Stream</code> ，它是通过走根据给定的起始文件的文件树懒惰地填充  <code>Path</code> 。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>walkFileTree(Path start, FileVisitor&lt;? super Path&gt; visitor)</code>  <br>走一个文件树。</td>
</tr>
<tr>
<td align="left"><code>static Path</code></td>
<td><code>walkFileTree(Path start, Set&lt;FileVisitOption&gt; options,  int maxDepth, FileVisitor&lt;? super Path&gt; visitor)</code>  <br>走一个文件树。</td>
</tr>
<tr>
<td align="left"><code>static Stream&lt;Path&gt;</code></td>
<td><code>find(Path start, int maxDepth, BiPredicate&lt;Path,BasicFileAttributes&gt; matcher,  FileVisitOption... options)</code>  <br>返回一个 <code>Stream</code> ，它通过搜索基于给定起始文件的文件树中的文件来懒惰地填充  <code>Path</code> 。</td>
</tr>
</tbody></table>
<h4 id="Path-amp-Paths"><a href="#Path-amp-Paths" class="headerlink" title="Path&amp;Paths"></a>Path&amp;Paths</h4><blockquote>
<p>建议复制下面代码跑一遍初略阅读，即可明白各个方法的含义</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOAPI</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// path1: C:\Users\Askia\Desktop\IOAPI.java</span></span><br><span class="line">		<span class="comment">// path2: C:\Users\Askia\Desktop\git-cheat-sheet.pdf</span></span><br><span class="line">		</span><br><span class="line">		Path path1 = Paths.get(<span class="string">&quot;C:&quot;</span>,<span class="string">&quot;\\Users&quot;</span>,<span class="string">&quot;\\Askia&quot;</span>,<span class="string">&quot;\\Desktop&quot;</span>, <span class="string">&quot;\\IOAPI.java&quot;</span>);</span><br><span class="line">		Path path2 = Paths.get(<span class="string">&quot;.\\&quot;</span>,<span class="string">&quot;git-cheat-sheet.pdf&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// equals(Object other)</span></span><br><span class="line">		System.out.println(<span class="string">&quot;两个路径是否相同：&quot;</span> + path1.equals(path2));</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;path1.toString：&quot;</span> + path1.toString());</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;获取文件名：&quot;</span> + path1.getFileName().toString());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// getName()方法index参数是要返回的名称元素的索引。 目录层次结构中最靠近根的元素具有索引0 。 离根最远的元素有索引count -1 。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;获取第一靠近根的名称元素：&quot;</span> + path1.getName(<span class="number">0</span>).toString());</span><br><span class="line">		System.out.println(<span class="string">&quot;获取第二靠近根的名称元素：&quot;</span> + path1.getName(<span class="number">1</span>).toString());</span><br><span class="line">		System.out.println(<span class="string">&quot;获取第三靠近根的名称元素：&quot;</span> + path1.getName(<span class="number">2</span>).toString());</span><br><span class="line">		System.out.println(<span class="string">&quot;获取第四靠近根的名称元素：&quot;</span> + path1.getName(<span class="number">3</span>).toString());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// getNameCount()方法如果此路径仅表示根组件，返回0</span></span><br><span class="line">		System.out.println(<span class="string">&quot;获取名称元素总数量：&quot;</span> + path1.getNameCount());</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;获取父路径：&quot;</span> + path1.getParent().toString());</span><br><span class="line">	</span><br><span class="line">		System.out.println(<span class="string">&quot;获取根路径：&quot;</span> + path1.getRoot().toString());</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;path1是否为绝对路径：&quot;</span> + path1.isAbsolute());</span><br><span class="line">		System.out.println(<span class="string">&quot;path2是否为绝对路径：&quot;</span> + path2.isAbsolute());</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;消除C:\\Users\\..\\Askia\\.\\Desktop\\..\\IOAPI.java路径的冗余名称元素：&quot;</span>+Paths.get(<span class="string">&quot;C:\\Users\\..\\Askia\\.\\Desktop\\..\\IOAPI.java&quot;</span>).normalize());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// relativize比较的必须是同一个根</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			API说明：</span></span><br><span class="line"><span class="comment">			该方法尝试构建一个relative路径，当路径resolved针对该路径生成与给定路径相同的文件路径。 例如，在UNIX上，如果此路径为&quot;/a/b&quot; ，给定路径为&quot;/a/b/c/d&quot;则相应的路径为&quot;c/d&quot; 。 在此路径和给定路径中没有root组件的情况下，可以构建相对路径。 如果只有一个路径具有根组件,而另外一个没有根组件，则不能构造相对路径。 如果两个路径都有一个根组件，那么如果可以构造一个相对路径，那么它是依赖于实现的。 如果此路径和给定路径为equal，则返回空路径 </span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		System.out.println(<span class="string">&quot;在path1路径中表示path2路径(相当于参数-path1)：&quot;</span> + path1.relativize(Paths.get(<span class="string">&quot;C:\\Users\\&quot;</span>)));</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			API说明：</span></span><br><span class="line"><span class="comment">			如果参数是绝对路径，则返回绝对路径,否则，返回连接后的路径</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		System.out.println(<span class="string">&quot;path1连接path2：&quot;</span> + path1.resolve(path2));</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			API说明：</span></span><br><span class="line"><span class="comment">			如果参数是绝对路径，则返回绝对路径,否则，返回连接后的路径</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		System.out.println(<span class="string">&quot;path1的父路径连接path2：&quot;</span> + path1.resolveSibling(<span class="string">&quot;newIOAPI.java&quot;</span>));</span><br><span class="line">        </span><br><span class="line">		System.out.println(<span class="string">&quot;取名称元素1-3（不包括3）为子路径：&quot;</span>+path1.subpath(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line">        </span><br><span class="line">		System.out.println(<span class="string">&quot;返回path2的绝对路径：&quot;</span>+path2.toAbsolutePath());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两个路径是否相同：false</span><br><span class="line">path1.toString：C:\Users\Askia\Desktop\IOAPI.java</span><br><span class="line">获取文件名：IOAPI.java</span><br><span class="line">获取第一靠近根的名称元素：Users</span><br><span class="line">获取第二靠近根的名称元素：Askia</span><br><span class="line">获取第三靠近根的名称元素：Desktop</span><br><span class="line">获取第四靠近根的名称元素：IOAPI.java</span><br><span class="line">获取名称元素总数量：4</span><br><span class="line">获取父路径：C:\Users\Askia\Desktop</span><br><span class="line">获取根路径：C:\</span><br><span class="line">path1是否为绝对路径：true</span><br><span class="line">path2是否为绝对路径：false</span><br><span class="line">消除C:\Users\..\Askia\.\Desktop\..\IOAPI.java路径的冗余名称元素：C:\Askia\IOAPI.java</span><br><span class="line">在path1路径中表示path2路径(相当于参数-path1)：..\..\..</span><br><span class="line">path1连接path2：C:\Users\Askia\Desktop\IOAPI.java\.\git-cheat-sheet.pdf</span><br><span class="line">path1的父路径连接path2：C:\Users\Askia\Desktop\newIOAPI.java</span><br><span class="line">取名称元素1-3（不包括3）为子路径：Askia\Desktop</span><br><span class="line">返回path2的绝对路径：C:\Users\Askia\Desktop\.\git-cheat-sheet.pdf</span><br></pre></td></tr></table></figure>

<h4 id="Files-1"><a href="#Files-1" class="headerlink" title="Files"></a>Files</h4><h5 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建的目录,注意假设创建的目录为C:\windows\file\tempfile,则C:\windows\file目录必须是已经存在的，否则会抛出异常。</span></span><br><span class="line">Files.createDirectory(path);	</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以创建任意目录，即便父目录不存在也可以一并创建</span></span><br><span class="line">Files.createDirectories(path);</span><br></pre></td></tr></table></figure>

<h5 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建文件直接调用createFile()方法如果文件已存在会抛出异常，因此最好的创建方式如下:</span></span><br><span class="line"><span class="keyword">if</span>(Files.notExists(path))&#123;</span><br><span class="line">	Files.createFile(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意不能用exists方法！noExist只能判断出文件不存在，exists只能判断出文件存在，这两个方法返回false的时候没法判断文件存在/不存在，还有一种不能确定的可能！！！</span></span><br></pre></td></tr></table></figure>

<h5 id="创建临时目录、临时文件"><a href="#创建临时目录、临时文件" class="headerlink" title="创建临时目录、临时文件"></a>创建临时目录、临时文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path tmpFile1 = Files.createTempFile(<span class="string">&quot;C:\\temp\\&quot;</span>, <span class="string">&quot;wif23idah312s&quot;</span>, <span class="string">&quot;.txt&quot;</span>); <span class="comment">// C:\temp\wif23idah312s.txt</span></span><br><span class="line">Path tmpFile2 = Files.createTempFile(<span class="string">&quot;wif23idah312s&quot;</span>, <span class="string">&quot;.txt&quot;</span>);	<span class="comment">//	%temp%\wif23idah312s.txt</span></span><br><span class="line">Path tmpDir1 = Files.createTempDirectory(<span class="string">&quot;C:\\temp\\&quot;</span>, <span class="string">&quot;wif23idah312s&quot;</span>)	 <span class="comment">// C:\temp\wif23idah312s\</span></span><br><span class="line">Path tmpDir2 = Files.createTempDirectory(<span class="string">&quot;wif23idah312s&quot;</span>);		<span class="comment">// %temp%\wif23idah312s\</span></span><br></pre></td></tr></table></figure>

<h5 id="复制、移动和删除文件"><a href="#复制、移动和删除文件" class="headerlink" title="复制、移动和删除文件"></a>复制、移动和删除文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.copy(frompath, topath);	<span class="comment">// 复制文件，若文件已存在则抛出异常</span></span><br><span class="line">Files.move(frompath, topath);	<span class="comment">// 复制文件，若文件已存在则抛出异常</span></span><br></pre></td></tr></table></figure>

<p>最后的参数为选项（枚举类<code>StandardCopyOption</code>）</p>
<p>对于复制：</p>
<ul>
<li>StandardCopyOption.REPLACE_EXISTING：复制若已存在，则覆盖文件。</li>
<li>StandardCopyOption.COPY_ATTRIBUTES：复制所有文件属性</li>
</ul>
<p>对于移动：</p>
<ul>
<li>StandardCopyOption.ATOMIC_MOVE：原子性移动，保证要么移动成功，要么源文件继续留在原地</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.copy(frompath, topath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);	</span><br><span class="line">Files.move(frompath, topath, StandardCopyOption.ATOMIC_MOVE);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Files.delete(path);	//直接删除文件，该文件已知存在！</span><br><span class="line">Files.deleteIfExists(path);	//如果文件存在删除文件！</span><br></pre></td></tr></table></figure>

<h5 id="简单读写"><a href="#简单读写" class="headerlink" title="简单读写"></a>简单读写</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = Files.readAllBytes(path);</span><br><span class="line"><span class="keyword">var</span> content = Files.readString(path, charset);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>部分方法可能要涉及到<code>OpenOption</code>选项（<code>StandardOpenOption</code>枚举类）下面给出可用的选项：</p>
<ul>
<li><p>StandardOpenOption.WRITE：覆盖在原有内容上写</p>
</li>
<li><p>StandardOpenOption.APPEND：追加写</p>
</li>
<li><p>StandardOpenOption.TRUNCATE_EXISTING：清空内容再写</p>
</li>
</ul>
<h2 id="输入输出流、字节读写与字符串读写"><a href="#输入输出流、字节读写与字符串读写" class="headerlink" title="输入输出流、字节读写与字符串读写"></a>输入输出流、字节读写与字符串读写</h2><h3 id="输入输出字节流"><a href="#输入输出字节流" class="headerlink" title="输入输出字节流"></a>输入输出字节流</h3><p>在JavaAPI中，<strong>可以从其中读入一个字节序列的对象为输入流，可以从其中写出一个字节序列的对象为输出流。</strong></p>
<p>**抽象类<code>InputStream</code>和<code>OutputStream</code>**构成了基本的I/O结构，Java拥有一个流家族来满足不同的需求。(建议看不清的同学,把图单独放大看！)</p>
<img src="/2021/08/12/Java/JavaIO%E6%B5%81/javaio.bmp" alt="javaio" style="zoom: 200%;">

<p>Java对于流采用了一种嵌套的方式进行处理，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fisStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\1.txt&quot;</span>);</span><br><span class="line">StringBufferInputStream sbis = <span class="keyword">new</span> StringBufferInputStream(fisStream);	<span class="comment">// FileInputStream --&gt;StringBufferInputStream</span></span><br></pre></td></tr></table></figure>

<h4 id="InputStream-amp-OutputStream"><a href="#InputStream-amp-OutputStream" class="headerlink" title="InputStream&amp;OutputStream"></a>InputStream&amp;OutputStream</h4><p>InputStream是所有输入类的抽象父类，该类定义了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>;						<span class="comment">// 读入一个字节，并返回，碰到输入流结尾返回-1，所有子类必须重写该方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span>;						<span class="comment">// 读入一个字节数组，返回实际读入的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span>;	<span class="comment">// 读入一个字节数组，从off开始，长度len，返回实际读入的字节数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] readAllBytes();					<span class="comment">// 读入当前流中的所有字节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">transferTo</span><span class="params">(OutputStream out)</span></span>;		<span class="comment">// 将该输入流的字节抛给输出流，返回实际抛给的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span>;						<span class="comment">// 跳过n个字节</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">available</span><span class="params">()</span>									<span class="comment">// 返回不阻塞的情况下可获取的字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>									<span class="comment">// 关闭这个输入流</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span>					<span class="comment">// 如果这个流支持打标记，则返回true</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span></span>;				<span class="comment">// 对当前位置readlimit打标记，如果已经读入的字节超过readlimit，则忽略标记</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span>								<span class="comment">// 返回最后一次标记的地方继续读取数据</span></span></span><br></pre></td></tr></table></figure>

<p>其他的API都已经很明确用途了，这里只讲一个<code>available()</code></p>
<p>read()、Write()执行都会阻塞，直至字节确实被读入或者写出了。通俗点说，<strong>在操作流的时候，流是不能说访问就访问的，要等到流中确实有字节了，才可以真正访问</strong>，特别在<strong>网络连接繁忙的环境中</strong>，字节被放进流里面<strong>可能需要很长时间</strong>，因此程序可能会<strong>停下来等待</strong>。使用<code>available()</code>则可以进一步解决这个问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int byteAvailable = in.available();			// 读入可访问的字节数</span><br><span class="line">if(byteAvailable &gt; 0)&#123;						// 如果有字节，读入，没有则先不读，把控制权交还给程序</span><br><span class="line">	byte[] d = new byte[byteAvailable];</span><br><span class="line">	in.read(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OutputStream是所有输出类的抽象父类，该类定义了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> n)</span>				<span class="comment">// 写出一个字节的数据。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span>	</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> 	<span class="comment">// 写出全部字节或者部分字节到byte数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span>								<span class="comment">// 刷新输出流</span></span></span><br></pre></td></tr></table></figure>

<h4 id="InputStream子类"><a href="#InputStream子类" class="headerlink" title="InputStream子类"></a>InputStream子类</h4><h5 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h5><p>创建一个能从文件读取字节的<code>InputStream</code>类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileInputStream(String name)</span><br><span class="line">FileInputStream(File file)</span><br></pre></td></tr></table></figure>

<p>append：如果参数为true，对于任何数据都将被添加到文件尾，而且具有相同名字的已有文件不会被删除，false时删除全部具有相同名字的文件。</p>
<h5 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h5><p>创建一个带缓冲区的流对象，流默认是不带缓冲区的，因此，对于read方法的调用，都会直接向系统申请分发字节。如果把一个数据块放在一个缓冲区中，每次读取从缓冲区中读取，这样可以减少直接访问系统而引起的中断次数，效率更高。要使用缓冲机制，需要使用类似于嵌套流的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> din = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(file)));</span><br></pre></td></tr></table></figure>

<p>正如上文所说，Java采用一种组合流的方法，赋予一个流多种属性。如上面的是带缓冲区的二进制数据输入流。</p>
<h5 id="PushbackInputStream"><a href="#PushbackInputStream" class="headerlink" title="PushbackInputStream"></a>PushbackInputStream</h5><p>创建一个可以回推字节的输入流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bin = <span class="keyword">new</span> PushbackInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;file.txt&quot;</span>)));</span><br><span class="line"><span class="keyword">int</span> b = bin.read();</span><br><span class="line"><span class="keyword">if</span>(b != <span class="string">&#x27;&gt;&#x27;</span>)&#123;</span><br><span class="line">	bin.unread(b);			<span class="comment">// 回退字节到流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="组合流"><a href="#组合流" class="headerlink" title="组合流"></a>组合流</h6><p>如果想要一个既可以推回又可以写出二进制数据的流，可参考：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PushbackInputStream pbin;</span><br><span class="line"><span class="keyword">var</span> bin = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">    pbin =  = <span class="keyword">new</span> PushbackInputStream(</span><br><span class="line">        <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">            <span class="keyword">new</span> FileInputStream(<span class="string">&quot;file.txt&quot;</span>)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="OutputStream子类"><a href="#OutputStream子类" class="headerlink" title="OutputStream子类"></a>OutputStream子类</h4><h5 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h5><p>创建一个写出字节到文件的<code>outputStream</code>类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileOutputStream(String name)</span><br><span class="line">FileOutputStream(String name, boolean append)</span><br><span class="line">FileOutputStream(File file)</span><br><span class="line">FileOutputStream(File file, boolean append)</span><br></pre></td></tr></table></figure>

<p>append：如果参数为true，对于任何数据都将被添加到文件尾，而且具有相同名字的已有文件不会被删除，false时删除全部具有相同名字的文件。</p>
<h5 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a>BufferedOutputStream</h5><p>创建一个带缓冲区的输出流，带缓冲区的输出流在填入数据时，不必每次都访问设备，当缓冲区填满或者刷新之后<code>（flush()）</code>，数据就被写出。</p>
<h3 id="字符串读写类"><a href="#字符串读写类" class="headerlink" title="字符串读写类"></a>字符串读写类</h3><p>Java对Unicode文本字符串读写采用的是<code>Reader</code>和<code>Writer</code>抽象类：</p>
<p><img src="/2021/08/12/Java/JavaIO%E6%B5%81/javaReader&Writer.png" alt="javaReader&amp;Writer"></p>
<h3 id="字符串读写"><a href="#字符串读写" class="headerlink" title="字符串读写"></a>字符串读写</h3><h4 id="文本读写"><a href="#文本读写" class="headerlink" title="文本读写"></a>文本读写</h4><p>如何进行文件的读写呢？对于流来说处理的东西都是人没法直接看懂的字节流，如何将人能看懂的文本进行简单的读写，本小节来讨论。</p>
<p>首先如何读一个文件中的文本呢？java采用相同的组合过滤器的解决方案：对于任意的流数据，可以通过<code>InputStreamReader</code>类来转换为文本的<code>Reader</code>，在转换过程中，可以指定编码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader strin = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;file.txt&quot;</span>), StandardCharsets.UTF_8);</span><br><span class="line">InputStreamReader strin = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;file.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>然后，如何读写文本呢？如今最常用的是使用<code>Scanner</code>类，对于早期的Java提供的一个<code>BufferedReader</code>配合<code>InputStreamReader</code>来读入文本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InputStream inp = ...;</span><br><span class="line">try(var in = new BufferedReader(new InputStreamReader(inp,StandardCharset.UTF_8)))&#123;</span><br><span class="line">	String line;</span><br><span class="line">	while((line = in.readLine())!=null)&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Scanner类读入文本，这里单独介绍：</p>
<h5 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h5><p>作为一个处理输入的类，提供了简单的对字符串、对数字的输入处理，对于该类的构造，常用的方式如下;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scanner sc = new Scanner(InputStream);</span><br><span class="line">Scanner sc = new Scanner(InputStream, charset);</span><br></pre></td></tr></table></figure>

<h6 id="对于字符串输入"><a href="#对于字符串输入" class="headerlink" title="对于字符串输入"></a>对于字符串输入</h6><p>对于字符串输入，主要有hasNext()、hasNextLine()、next()、nextLine()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"> </span><br><span class="line">public class ScannerDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.in);</span><br><span class="line">        // 从键盘接收数据</span><br><span class="line"> </span><br><span class="line">        // nextLine方式接收字符串</span><br><span class="line">        System.out.println(&quot;nextLine方式接收：&quot;);</span><br><span class="line">        // 判断是否还有输入</span><br><span class="line">        if (scan.hasNextLine()) &#123;</span><br><span class="line">            String str2 = scan.nextLine();</span><br><span class="line">            System.out.println(&quot;输入的数据为：&quot; + str2);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于next()、nextLine()区别：</p>
<p><img src="/2021/08/12/Java/JavaIO%E6%B5%81/image-20210328200509649.png" alt="image-20210328200509649"></p>
<h6 id="对于数字输入"><a href="#对于数字输入" class="headerlink" title="对于数字输入"></a>对于数字输入</h6><p>对于数字的输入，主要有hasNextXXX()、nextXXX()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"> </span><br><span class="line">public class ScannerDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.in);</span><br><span class="line">        // 从键盘接收数据</span><br><span class="line">        int i = 0;</span><br><span class="line">        float f = 0.0f;</span><br><span class="line">        System.out.print(&quot;输入整数：&quot;);</span><br><span class="line">        if (scan.hasNextInt()) &#123;</span><br><span class="line">            // 判断输入的是否是整数</span><br><span class="line">            i = scan.nextInt();</span><br><span class="line">            // 接收整数</span><br><span class="line">            System.out.println(&quot;整数数据：&quot; + i);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 输入错误的信息</span><br><span class="line">            System.out.println(&quot;输入的不是整数！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;输入小数：&quot;);</span><br><span class="line">        if (scan.hasNextFloat()) &#123;</span><br><span class="line">            // 判断输入的是否是小数</span><br><span class="line">            f = scan.nextFloat();</span><br><span class="line">            // 接收小数</span><br><span class="line">            System.out.println(&quot;小数数据：&quot; + f);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 输入错误的信息</span><br><span class="line">            System.out.println(&quot;输入的不是小数！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，对于写出文本，可以使用Writer类中的<code>PrintWriter</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PrintWriter pw = new PrintWriter(&quot;file.txt&quot;, StandardCharset.UTF_8);</span><br><span class="line">pw.print(&quot;abc&quot;);</span><br><span class="line">pw.println(&quot;abc&quot;);</span><br></pre></td></tr></table></figure>

<p>对于<code>PrintWriter</code>常用的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PrintWriter(Writer out)</span><br><span class="line">PrintWriter(String filepath, String charset)</span><br><span class="line">PrintWriter(File file, String charset)</span><br><span class="line">// 常用的方法</span><br><span class="line"></span><br><span class="line">print(Object obj);该方法将调用obj的toString()</span><br><span class="line">println();</span><br><span class="line">print();</span><br><span class="line">printf(String fomat, object ...args);</span><br></pre></td></tr></table></figure>

<h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><h3 id="二进制文件读写"><a href="#二进制文件读写" class="headerlink" title="二进制文件读写"></a>二进制文件读写</h3><h3 id="文件随机访问"><a href="#文件随机访问" class="headerlink" title="文件随机访问"></a>文件随机访问</h3><h2 id="ZIP文档"><a href="#ZIP文档" class="headerlink" title="ZIP文档"></a>ZIP文档</h2><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>所谓序列化，<strong>即为将对象写出输出流中，在特定的时期再将其读回</strong>，序列的一种用法是将对象保存在磁盘文件中，在必要的时候，通过读入文件的方法重新加载对象，这样在服务器等内存资源比较有限的场合可以达到减轻内存负担的效果。</p>
<h3 id="保存对象和加载对象"><a href="#保存对象和加载对象" class="headerlink" title="保存对象和加载对象"></a>保存对象和加载对象</h3><p>要保存一个对象(序列化)，需要：</p>
<ol>
<li>首先打开一个<code>ObjectOutputStream</code>对象：</li>
<li>调用<code>writeObject()</code>s</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> harry = <span class="keyword">new</span> Employee();</span><br><span class="line"><span class="keyword">var</span> out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;file.txt&quot;</span>));</span><br><span class="line">out.writeObject(harry);</span><br></pre></td></tr></table></figure>

<p>要加载一个对象，则需要：</p>
<ol>
<li>打开一个ObjectInputStream</li>
<li>调用<code>readObject()</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;file.txt&quot;</span>));</span><br><span class="line"><span class="keyword">var</span> harry = (Employee)in.readObject();</span><br></pre></td></tr></table></figure>

<p>并且，能够序列化的类都要实现标记接口<code>Serializable</code>！！！</p>
<h4 id="对引用字段的处理"><a href="#对引用字段的处理" class="headerlink" title="对引用字段的处理"></a>对引用字段的处理</h4><h3 id="序列化文件格式"><a href="#序列化文件格式" class="headerlink" title="序列化文件格式"></a>序列化文件格式</h3><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="ZIP文件系统"><a href="#ZIP文件系统" class="headerlink" title="ZIP文件系统"></a>ZIP文件系统</h3><h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><h2 id="文件加锁"><a href="#文件加锁" class="headerlink" title="文件加锁"></a>文件加锁</h2><h2 id="关于Close方法"><a href="#关于Close方法" class="headerlink" title="关于Close方法"></a>关于Close方法</h2><p><code>javaIO</code>流家族采用装饰模式来设计，因此在调用<code>close()</code>的时候，实际上是调用被装饰对象的<code>close()</code>，因此理论上关闭的顺序没有约定！因为<code>close()</code>方法允许多次调用（当然也有特例，后面讲！），因为规定关闭先前关闭的流没有任何效果。</p>
<p><img src="/2021/08/12/Java/JavaIO%E6%B5%81/image-20210601181038674.png" alt="image-20210601181038674"></p>
<p>然后，我们再细看<code>close()</code>方法</p>
<p>对于<code>BufferedInoutStream</code></p>
<p><img src="/2021/08/12/Java/JavaIO%E6%B5%81/image-20210601181216077.png" alt="image-20210601181216077"></p>
<p>DataInputStream类：</p>
<p><img src="/2021/08/12/Java/JavaIO%E6%B5%81/image-20210601181248404.png" alt="image-20210601181248404"></p>
<p>其中<code>in</code>为装饰对象，在这里为<code>inputstream</code>，可见实际上底层还是调用顶层的<code>close()</code>，因此我们还可以直接调用<code>inputstream.close()</code>，而无需调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dataInputStream.close();</span><br><span class="line">bufferedInputStream.close();</span><br></pre></td></tr></table></figure>

<p>但有例外，比如以下代码会抛出异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OutputStreamWriter writer = new OutputStreamWriter(System.out);</span><br><span class="line">BufferedWriter writer1 = new BufferedWriter(writer);</span><br><span class="line">PrintWriter writer2 = new PrintWriter(writer1);</span><br><span class="line">writer2.close();</span><br><span class="line">writer1.close();</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure>

<p>原因在于<code>BufferedWriter writer1</code>，看一下他的<code>close()</code></p>
<p><img src="/2021/08/12/Java/JavaIO%E6%B5%81/image-20210601182024659.png" alt="image-20210601182024659"></p>
<p>其中的flushBuffer()方法：</p>
<p><img src="/2021/08/12/Java/JavaIO%E6%B5%81/image-20210601182110249.png" alt="image-20210601182110249"></p>
<p>这里需要写空缓冲，因此抛出异常的原因知道了，当我们调用<code>writer2.close()</code>没实际上流已经关闭，但是再次调用<code>writer1.close()</code>会运行上面的<code>out.write()</code>，由于流已经关闭，因此会抛出异常。</p>
<p>这一类情况一般发生在BufferedWriter或Writer中，因此关闭流要优先关闭这一类流。</p>
]]></content>
      <categories>
        <category>java学习笔记</category>
      </categories>
      <tags>
        <tag>java_core</tag>
        <tag>java_lib</tag>
      </tags>
  </entry>
  <entry>
    <title>about</title>
    <url>/about/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>archives</title>
    <url>/archives/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
